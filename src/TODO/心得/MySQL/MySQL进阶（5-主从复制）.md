---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 主从复制

### 工作原理
![](MySQL进阶（5-主从复制）/1.png)

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中
3. 从服务器重做中继日志中的日志，把更改应用到自己的数据库中，以达到数据的最终一致性

![](MySQL进阶（5-主从复制）/2.png)

### 涉及线程
1. binlog 线程：负责将主服务器上的数据更改写入二进制日志中
2. I/O 线程：负责从主服务器上读取二进制日志，并写入从服务器的重放日志中
3. SQL 线程：负责读取重放日志并重放其中的 SQL 语句

### 从库数量
从库是不是越多越好？不是的。

因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。

所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。

### 主从复制模型
1. 同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。
2. 异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。
3. 半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。

### 主从同步的延迟原因
假如一个服务器开放 N 个连接给客户端，这样会有大并发的更新操作，但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里，这就导致了主从不一致

### 主从同步延迟的解决方法
1. sync_binlog 在 Slave 端设置为 0
2. log-slave-updates 从服务器从主服务器接受的更新日志不计入二进制日志
3. 直接禁用 Slave 的 binlog
4. Slave 端，如果存储引擎是 innodb，innodb_flush_log_at_trx_commit = 2
5. 同步参数调整主库是写，对数据安全性较高，比如：sync_binlog = 1，innodb_flush_log_at_trx_commit = 1 之类的设置是需要的，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog，innodb_flushlog 也可以设置为 0 来提高 sql 的执行效率

sync_binlog = 1：MySQL 提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上去。默认，sync_binlog = 0，表示 MySQL 不控制 binlog 的刷新，由文件系统自己控制它的缓存的刷新，这时候的性能是最好的，但是风险也是最大的，一旦系统 crash，在 binlog_cache 中的所有 binlog 信息都会被丢失。

如果 sync_binlog > 0，表示每 sync_binlog 次事务提交，MySQL 调用文件系统的刷新操作将缓存刷下去。最安全的就是 sync_binlog = 1 了，表示每次事务提交，MySQL 都会把 binlog 刷下去，是最安全但是性能损耗最大的设置，这样的话，在数据库所在的主机操作系统损坏或者突然掉电的情况下，系统才有可能丢失 1 个事务的数据。虽然 binlog 是顺序 IO，但是设置 sync_binlog = 1，多个事务同时提交，同样很大的影响 MySQL 和 IO 性能，虽然可以通过 group commit 的补丁缓解，但是刷新的频率过高对 IO 的影响也非常大。对于高并发事务的系统来说，sync_binlog 设置为 0 和设置为 1 的系统写入性能差距可能高达 5 倍甚至更多，所以很多 MySQL DBA 设置的 sync_binlog 并不是最安全的 1，而是 0 或 2，这样牺牲一定的一致性，可以获取更高的并发和性能

innodb_flush_log_at_trx_commit：默认值 1 的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的，特别是使用电池供电缓存时。设成 2 对于很多应用，特别是从 MyISAM 表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存，日志仍然会每秒 flush 到硬盘，所以你一般不会丢失超过 1-2 秒的更新。设成 0 会更快一点，但安全方面比较差，即使 MySQL 挂了可能会丢失事务的数据，而值 2 只会在整个操作系统挂了时才可能丢失数据

+ 增加从服务器，目的是分散读的压力，从而降低服务器负载

## 读写分离
读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器，主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作

### 提高性能的原因
1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用
2. 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销
3. 增加冗余，提供可用性

### 实现方案
MySQL 读写分离的实现方式主要基于主从复制，通过路由的方式使应用对数据库的写请求只在 Master 上进行，读请求在 Slave 上进行

1. 基于 MySQL proxy 代理

在应用和数据库之间增加代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等

![](MySQL进阶（5-主从复制）/3.png)

2. 基于应用内路由

基于应用内路由的方式即在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。具体实现可基于 Spring 的 aop，用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源

![](MySQL进阶（5-主从复制）/4.png)

3. 基于 MySQL-Connector-Java 的 JDBC 驱动方式

Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外，MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡

4. 基于 sharding-jdbc 的方式

sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块

