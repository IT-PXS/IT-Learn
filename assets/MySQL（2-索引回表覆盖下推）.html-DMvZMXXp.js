import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as n}from"./app-arQAAk6n.js";const e="/IT-Learn/assets/1-BXMcYmFk.png",t="/IT-Learn/assets/2-CeQGO7l3.png",h="/IT-Learn/assets/3-D4d9N5Oc.png",k="/IT-Learn/assets/4-Bs9wWjXP.png",p={};function r(d,i){return n(),a("div",null,[...i[0]||(i[0]=[l(`<h2 id="回表查询" tabindex="-1"><a class="header-anchor" href="#回表查询"><span>回表查询</span></a></h2><p>如果索引的列在 select 所需获取的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表</p><p><strong>产生场景</strong></p><ol><li>查询字段不全：当查询的字段不完全包含在索引中时，MySQL需要通过主键或唯一键，从表中取出其他字段。</li><li>复合索引未覆盖所有查询字段：如果查询条件包含组合索引的一部分字段，但没有包含所有字段，MySQL也需要回表查询。</li></ol><p><strong>使用案例</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> xttblog</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> primary key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    k </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> not null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (k)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)engine </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> InnoDB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xttblog </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ID </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 这条 SQL 语句就不需要回表。原因是根据主键的查询方式，则只需要搜索 ID 这棵 B+ 树。主键是唯一的，根据这个唯一的索引，MySQL 就能确定搜索的记录。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> xttblog </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 通过 k 这个普通索引查询方式，则需要先搜索 k 索引树，然后得到主键 ID 的值为 1，再到 ID 索引树搜索一次。这个过程虽然用了索引，但实际上底层进行了两次索引查询，这个过程就称为回表。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong></p><ol><li>基于非主键索引的查询需要多扫描一颗索引树</li><li>使用聚集索引（主键或第一个唯一索引）就不会回表，普通索引可能会回表</li></ol><h2 id="索引覆盖" tabindex="-1"><a class="header-anchor" href="#索引覆盖"><span>索引覆盖</span></a></h2><ol><li>索引覆盖：只需要在一颗索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快</li><li>查看触发情况：explain 的输出结果 Extra 字段为 Using index 时即触发索引覆盖</li><li>实现索引覆盖的方法：将被查询的字段，建立到索引里去</li></ol><p><strong>使用案例</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> users</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 主键</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),           </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 用户名</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    email </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 邮箱</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    age </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,                    </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 年龄</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_name_email (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, email) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>索引覆盖的情况</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, email </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 索引 idx_name_email 包含 name 和 email，查询的字段完全被索引覆盖。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- MySQL 可以直接从索引中返回结果，无需访问实际表数据。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>索引不覆盖的情况</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, email, age </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 索引 idx_name_email 包含了 name 和 email，但不包含 age。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查询时，MySQL 会从索引中找到符合 name = &#39;Alice&#39; 的记录，然后通过主键回表查找 age 字段。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>索引部分使用的情况</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> email </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Alice&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查询使用索引 idx_name_email 的 name 列作为过滤条件，并获取email 列。这依然属于索引覆盖查询，因为所需的字段都在索引中。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="索引下推-icp" tabindex="-1"><a class="header-anchor" href="#索引下推-icp"><span>索引下推（ICP）</span></a></h2><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>索引下推（Index Condition Pushdown，简称 ICP）：指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，它能减少回表查询次数，提高查询效率。</p><p><strong>使用原理</strong></p><ol><li>在没有使用 ICP 的情况下</li></ol><ul><li>存储引擎读取索引记录</li><li>根据索引中的主键值，定位并读取完整的行记录</li><li>存储引擎把记录交给 Server 层去检测该记录是否满足 WHERE 条件</li></ul><ol start="2"><li>使用 ICP 的情况下</li></ol><ul><li>存储引擎读取索引记录（不是完整的行记录）</li><li>判断 WHERE 条件部分能否用索引中的列来做检查。条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（回表）</li><li>存储引擎把记录交给 Server 层，Server 层检测该记录是否满足除 WHERE 条件的其他部分</li></ul><p><strong>使用条件</strong></p><ol><li>只能用于 range、ref、eq_ref、ref_or_null 访问方法；</li><li>只能用于 InnoDB 和 MyISAM 存储引擎及其分区表；</li><li>对 InnoDB 存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）; 对于 InnoDB 的聚簇索引来说，数据和索引是在一起的，不存在回表这一说。</li><li>引用了子查询的条件不能下推；</li><li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li></ol><p><strong>使用案例</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 检索出表中名字第一个字是张，而且年龄是 10 岁的所有用户</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tuser </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> like</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;张%&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> age</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>没有使用 ICP</li></ol><p>在 MySQL5.6 之前，存储引擎根据通过联合索引找到 name like &#39;张%&#39;的主键 id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server 层再对数据 age = 10 进行筛选。可以看到需要回表两次，浪费了字段 age</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>使用 ICP</li></ol><p>MySQL5.6 以后，存储引擎根据（name，age）联合索引，找到 name like &#39;张%&#39;，由于联合索引中包含 age 列，所以存储引擎直接在联合索引里按照 age = 10 过滤，按照过滤后的数据再一一进行回表扫描，只回表了一次，使用 explain 查询，Extra 列中有 Using index condition</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',38)])])}const c=s(p,[["render",r]]),o=JSON.parse('{"path":"/More/MySQL/MySQL%EF%BC%882-%E7%B4%A2%E5%BC%95%E5%9B%9E%E8%A1%A8%E8%A6%86%E7%9B%96%E4%B8%8B%E6%8E%A8%EF%BC%89.html","title":"MySQL（2-回表查询、索引覆盖和下推）","lang":"zh-CN","frontmatter":{"title":"MySQL（2-回表查询、索引覆盖和下推）","tag":"MySQL","category":"心得","date":"2025-05-15T22:38:34.000Z","description":"回表查询 如果索引的列在 select 所需获取的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表 产生场景 查询字段不全：当查询的字段不完全包含在索引中时，MySQL...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL（2-回表查询、索引覆盖和下推）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-15T22:38:34.000Z\\",\\"dateModified\\":\\"2025-09-25T13:39:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"爱编程的小生\\",\\"url\\":\\"https://it-pxs.github.io/IT-Learn/\\"}]}"],["meta",{"property":"og:url","content":"https://it-pxs.github.io/IT-Learn/IT-Learn/More/MySQL/MySQL%EF%BC%882-%E7%B4%A2%E5%BC%95%E5%9B%9E%E8%A1%A8%E8%A6%86%E7%9B%96%E4%B8%8B%E6%8E%A8%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"爱编程的小生"}],["meta",{"property":"og:title","content":"MySQL（2-回表查询、索引覆盖和下推）"}],["meta",{"property":"og:description","content":"回表查询 如果索引的列在 select 所需获取的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表 产生场景 查询字段不全：当查询的字段不完全包含在索引中时，MySQL..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-25T13:39:55.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2025-05-15T22:38:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-25T13:39:55.000Z"}]]},"git":{"createdTime":1758807595000,"updatedTime":1758807595000,"contributors":[{"name":"penggengxin","username":"penggengxin","email":"penggengxin@grgbanking.com","commits":1,"url":"https://github.com/penggengxin"}]},"readingTime":{"minutes":4.69,"words":1408},"filePathRelative":"More/MySQL/MySQL（2-索引回表覆盖下推）.md","autoDesc":true}');export{c as comp,o as data};
