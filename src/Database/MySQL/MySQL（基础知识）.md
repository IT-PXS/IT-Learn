---
title: MySQL（基础知识）
tag: MySQL
category: 数据库
description: MySQL是一个广泛使用的开源关系型数据库管理系统，适用于多种应用场景。MySQL基础知识涵盖数据库和表的创建与管理、数据类型、常用SQL语句（如SELECT、INSERT、UPDATE、DELETE等）及其使用方法。
published: false
abbrlink: 40028
date: 2024-11-09 22:38:34
---

## 基础知识

### 格式

1. SQL 语句可以单行或多行书写，以分号结尾
2. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写

### 注释

1. 单行注释：-- 注释内容 或 #注释内容（--必须加空格，#可以不加空格）

2. 多行注释：/*  注释  */

### SQL 分类

1. DDL（数据定义语言）：用来定义数据库对象：数据库，表，列等
2. DML（数据操作语言）：用来对数据库中表的数据进行增删改
3. DQL（数据查询语言）：用来查询数据库中表的记录
4. DCL（数据控制语言）：用来定义数据库的访问权限和安全级别、创建用户

## 规范化理论

### 函数依赖

1. 函数依赖

A-> B，如果通过 A 属性（属性组）的值，可以确定唯一 B 的值，则称 B 依赖于 A

例如：学号-> 姓名，（学号，课程名称）-> 分数

2. 完全函数依赖

A-> B，如果 A 是一个属性组，则 B 属性值的确定需要依赖于 A 属性组所有的值

例如：（学号，课程名称）-> 分数，需要根据学号和课程名称才能确定分数

3. 部分函数依赖

A-> B，如果 A 是一个属性值，则 B 属性值的确定需要依赖于 A 属性组某些值就行了

例如：（学号，课程名称）-> 姓名，学号和课程名称并不是 A 属性组里面的所有值

4. 传递函数依赖

A-> B，B-> C，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，再通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A

例如：学号-> 系名，系名-> 班主任

### 函数规则

FD 的推理规则（Armstrong 公理）有以下三条：

1. A1（自反性，Reflexivity）：若 Y⊆X⊆U，则 X→Y 在 R 上成立。
2. A2（增广性，Augmentation）：若 X→Y 在 R 上成立，且 Z⊆U，则 XZ→YZ 在 R 上成立。
3. A3（传递性，Transitivity）：若 X→Y 和 Y→Z 在 R 上成立，则 X→Z 在 R 上成立。

FD 的其他 5 条推理规则：

1. A4（合并性，Union）：{X→Y，X→Z} ⊢ X→YZ。
2. A5（分解性，Decomposition）：{X→Y，Z⊆Y} ⊢ X→Z。
3. A6（伪传递性）：{X→Y，WY→Z} ⊢ WX→Z。
4. A7（复合性，Composition）：{X→Y，W→Z} ⊢ XW→YZ。
5. A8：{X→Y，W→Z} ⊢ X∪(W－Y)→YZ。

### 码

码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码

1. 候选码（候选键）

若关系模式中的某一属性或属性组能唯一地标识一个元组，则称该属性或属性组为候选码（是最小超键，即没有多余元素的超键）。

例如：学号-> 性别、姓名，所以学号是学生关系模式的候选码

2. 主码（主键）

数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值 NULL（若一个关系模式有多个候选码，则选定其中一个为主码）

例如：学号-> 姓名，身份证号-> 姓名，所以可以选择学号作为主码

3. 超码（超键）：在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键，超键包含候选键和主键

例如：学号-> 性别，那么（学号, 姓名）-> 性别也是可以唯一确定的，所以可以称为学生关系模式的超码

4. 外码（外键）

在一个表中存在另一个表的主键称此表的外键，外键可以有重复的，可以是空值，外键是用来和其他表建立联系用的

5. 全码

如果在一个关系模式中，需要所有的属性才可以唯一标识其中的每一个元组，那么称这个属性组为全码

6. （非）主属性

包含在任何一个候选码中的所有属性称为主属性，反之称为非主属性

* 主属性：码属性组中的所有属性 
* 非主属性：除去码属性组的属性 

### 范式

设计关系数据库时，遵从不同的规范要求，设计出合理的关系式，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

**第一范式**

强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

```sql
SELECT * FROM `zz_student`;
+----------------------+--------+-------+
| student              | course | score |
+----------------------+--------+-------+
| 竹子，男，185cm      | 语文   |    95 |
| 竹子，男，185cm      | 数学   |   100 |
| 竹子，男，185cm      | 英语   |    88 |
| 熊猫，女，170cm      | 语文   |    99 |
| 熊猫，女，170cm      | 数学   |    90 |
| 熊猫，女，170cm      | 英语   |    95 |
+----------------------+--------+-------+

-- 第一范式修改后
+--------------+-------------+----------------+--------+-------+
| student_name | student_sex | student_height | course | score |
+--------------+-------------+----------------+--------+-------+
| 竹子         | 男          | 185cm          | 语文   |    95 |
| 竹子         | 男          | 185cm          | 数学   |   100 |
| 竹子         | 男          | 185cm          | 英语   |    88 |
| 熊猫         | 女          | 170cm          | 语文   |    99 |
| 熊猫         | 女          | 170cm          | 数学   |    90 |
| 熊猫         | 女          | 170cm          | 英语   |    95 |
+--------------+-------------+----------------+--------+-------+
```

**第二范式**

在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖），所谓完全依赖是指不能存在仅依赖码一部分的属性，必须是依赖全部属性（消除部分依赖）

```sql
+--------------+-------------+----------------+--------+-------+
| student_name | student_sex | student_height | course | score |
+--------------+-------------+----------------+--------+-------+
| 竹子         | 男          | 185cm          | 语文   |    95 |
| 竹子         | 男          | 185cm          | 数学   |   100 |
| 竹子         | 男          | 185cm          | 英语   |    88 |
| 熊猫         | 女          | 170cm          | 语文   |    99 |
| 熊猫         | 女          | 170cm          | 数学   |    90 |
| 熊猫         | 女          | 170cm          | 英语   |    95 |
+--------------+-------------+----------------+--------+-------+



-- 第二范式修改后
SELECT * FROM `zz_student`;
+------------+--------+------+--------+--------------+--------------+
| student_id | name   | sex  | height | department   | dean         |
+------------+--------+------+--------+--------------+--------------+
|          1 | 竹子   | 男   | 185cm  | 计算机系     | 竹子老大     |
|          2 | 熊猫   | 女   | 170cm  | 金融系       | 熊猫老大     |
+------------+--------+------+--------+--------------+--------------+

SELECT * FROM `zz_course`;
+-----------+-------------+
| course_id | course_name |
+-----------+-------------+
|         1 | 语文        |
|         2 | 数学        |
|         3 | 英语        |
+-----------+-------------+

SELECT * FROM `zz_score`;
+----------+------------+-----------+-------+
| score_id | student_id | course_id | score |
+----------+------------+-----------+-------+
|        1 |          1 |         1 |    95 |
|        2 |          1 |         2 |   100 |
|        3 |          1 |         3 |    88 |
|        4 |          2 |         1 |    99 |
|        5 |          2 |         2 |    90 |
|        6 |          2 |         3 |    95 |
+----------+------------+-----------+-------+
```

**第三范式**

在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）

```sql
SELECT * FROM `department`;
+---------------+-----------------+-----------------+
| department_id | department_name | department_dean |
+---------------+-----------------+-----------------+
|             1 | 计算机系        | 竹子老大        |
|             2 | 金融系          | 熊猫老大        |
+---------------+-----------------+-----------------+

SELECT * FROM `zz_student`;
+------------+--------+------+--------+---------------+
| student_id | name   | sex  | height | department_id |
+------------+--------+------+--------+---------------+
|          1 | 竹子   | 男   | 185cm  |             1 |
|          2 | 熊猫   | 女   | 170cm  |             2 |
+------------+--------+------+--------+---------------+
```

**BCNF**

关系模式 R（U，F）∈1NF，若 X-> Y 且 Y 不包含于 X 时，X 必含有码，则 R∈BCNF

+ 所有非主属性对每一个码都是完全函数依赖
+ 所有主属性对每一个不包含它的码是完全函数依赖
+ 没有任何属性完全函数依赖于非码的任何一组属性

BCNF 判断方法：X→Y 时，X 一定含有码（候选码中的任意一个，不能只是一个属性、部分码）

例如：在关系模式 STJ（S，T，J）中，S 表示学生，T 表示教师，J 表示课程。

每一教师只教一门课。每门课由一名教师教，某一学生选定某门课，就确定了一个固定的教师，某个学生选修某个教师的课就确定了所选课的名称：(S，J)→T，(S，T)→J，T→J

```sql
+-------------------+---------------+--------+------+--------+
| classes           | class_adviser | name   | sex  | height |
+-------------------+---------------+--------+------+--------+
| 计算机-2201班     | 熊竹老师      | 竹子   | 男   | 185cm  |
| 金融-2201班       | 竹熊老师      | 熊猫   | 女   | 170cm  |
| 计算机-2201班     | 熊竹老师      | 子竹   | 男   | 180cm  |
+-------------------+---------------+--------+------+--------+


-- 修改后
SELECT * FROM `zz_classes`;
+------------+-------------------+---------------+
| classes_id | classes_name      | class_adviser |
+------------+-------------------+---------------+
|          1 | 计算机-2201班     | 熊竹老师      |
|          2 | 金融-2201班       | 竹熊老师      |
+------------+-------------------+---------------+

SELECT * FROM `zz_student`;
+------------+--------+------+--------+
| classes_id | name   | sex  | height |
+------------+--------+------+--------+
|          1 | 竹子   | 男   | 185cm  |
|          2 | 熊猫   | 女   | 170cm  |
|          1 | 子竹   | 男   | 180cm  |
+------------+--------+------+--------+
```

**第四范式**

表中字段不能存在多值依赖关系，一个表中至少需要有三个独立的字段才会出现多值依赖问题，多值依赖是指表中的字段之间存在一对多的关系，也就是一个字段的具体值会由多个字段来决定。

**第五范式**

表中字段的数据之间不能存在连接依赖关系
