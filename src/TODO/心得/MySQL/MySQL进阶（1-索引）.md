---
title: MySQL进阶（1-索引）
series: MySQL
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 47834
date: 2025-05-15 22:38:34
description:
---

## 数据结构

### 哈希表

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。

哈希思路：把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是：链表。

注意：哈希表后的链表并不是有序的，区间查询的话需要扫描链表，所以哈希表这种结构适用于只有等值查询的场景

### 有序数组

如果仅仅看查询效率，有序数组是非常棒的数据结构。但是在需要更新数据的时候就麻烦了，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以有序数组索引只适用于静态存储引擎，比如：你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

### 二叉查找树

二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。在这种比较平衡的状态下查找时间复杂度是 O(log(n))。

但是二叉查找树存在一个问题：在某些极端情况下会退化成链表（例如有序数字：2,3,4,6,7,8），这个时候二叉查找树查找的时间复杂度就和链表一样，是 O(n)。

### 平衡二叉树（AVL）

AVL Trees (Balanced binary search trees) 平衡二叉树的定义：左右子树深度差绝对值不能超过 1。

既然平衡二叉树能通过左旋和右旋保持平衡，不会退化，那么我们用平衡二叉树存储索引可以吗？——可以的。

当我们用树的结构来存储索引的时候，访问一个节点就要跟磁盘之间发生一次 IO。 InnoDB 操作磁盘的最小的单位是一页（或者叫一个磁盘块）。与主存不同，磁盘 I/O 存在机械运动耗费，因此磁盘 I/O 的时间消耗是巨大的。

所以如果每个节点存储的数据太少，从索引中找到我们需要的数据，就要访问更多的节点，意味着跟磁盘交互次数就会过多。那么解决方案是什么？

1. 让每个节点存储更多的数据。
2. 让节点上有更多的关键字。

节点上的关键字的数量越多，我们的指针数也越多，也就是意味着可以有更多的分叉（我们把它叫做“路数”）。因为分叉数越多，树的深度就会减少(根节点是 0)。 这样，树就从瘦高变成了矮胖。这个时候，我们的树就不再是二叉了，而是多叉（或者叫做多路）。

### 多路平衡查找树（B-Tree）

B 树是一种多叉平衡查找树，主要特点：

1. B 树的节点中存储着多个元素，每个内节点有多个分叉。
2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
3. 父节点当中的元素不会出现在子节点中。
4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

注意：

1. B 树不支持范围查询的快速查找，如果我们想要查找 10 和 35 之间的数据，查找到 15 之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
2. 如果 data 存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘 IO 次数就会变大

### 加强版多路平衡查找树(B+Tree)

B+树，作为 B 树的升级版，MySQL 在 B 树的基础上继续改造，使用 B+树构建索引。B+树和 B 树最主要的区别在于非叶子节点是否存储数据的问题

1. B 树：非叶子节点和叶子节点都会存储数据。
2. B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

特点：

1. B+Tree 的磁盘读写能力相对于 B Tree 来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
2. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
3. 效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的）

### 总结

1. B+Tree vs B Tree

B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

2. B+Tree vs 二叉树

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为 O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

3. B+Tree vs Hash

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因

## 索引

### 使用原理

传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL 需要将表的数据从头到尾遍历一遍。

在我们添加完索引之后，MySQL 一般通过 BTREE 算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历，使用能够大幅地查询的效率的折半查找的方式，找到相应的键从而获取数据。

索引的出现是为了提高数据的查询效率，就像书的目录。但是，创建索引和维护索引需要耗费时间，创建索引是会产生索引文件的，占用磁盘空间。索引文件是一个二叉树类型的文件，DML 操作同样也会对索引文件进行修改，所以性能会相应的有所下降。

### 索引分类

1. 从物理存储角度

+ 聚簇索引
+ 非聚簇索引

2. 从数据结构角度

+ 树索引（O(log(n))）：在 InnoDB 引擎中使用的索引是 B+树，相较于二叉树，B+树这种多叉树更加矮宽，更适合存储在磁盘中
+ Hash 索引：通过 hash 算法快速定位数据，但不适合范围查询，因为每个 key 都要进行一次 hash

3. 从逻辑角度

+ 普通索引：MySQL 中的基本索引类型，允许在定义索引的列中插入重复值和空值
+ 唯一索引：要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一
+ 主键索引：特殊的唯一索引，不允许有空值
+ 组合索引：指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合
+ 全文索引：全文索引类型为 FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在 CHAR、VARCHAR 或者 TEXT 类型的列上创建。MySQL 中只有 MyISAM 存储引擎支持全文索引

### 建立索引的原则

1. 在最频繁使用的、用以缩小查询范围的字段上建立索引
2. 在频繁使用的、需要排序的字段上建立索引
3. 在查询中很少使用或者参考的列不要创建索引。由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求
4. 只有很少数据值的列也不应该增加索引。由于这些列的取值很少，区分度太小，例如：人事表中的性别，在查询时，需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度
5. 定义为 text、image 和 bit 数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少
6. 当修改性能远远大于检索性能时，不应该创建索引。因为二者是相互矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能
7. 定义有外键的数据列一定要创建索引

### 回表查询

如果索引的列在 select 所需获取的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表

**使用案例**

```mysql
create table xttblog(
    id int primary key, 
    k int not null, 
    name varchar(16),
    index (k)
)engine = InnoDB;
```

```mysql
select * from xttblog where ID = 2;
-- 这条 SQL 语句就不需要回表。原因是根据主键的查询方式，则只需要搜索 ID 这棵 B+ 树。主键是唯一的，根据这个唯一的索引，MySQL 就能确定搜索的记录。

select * from xttblog where k = 2;
-- 通过 k 这个普通索引查询方式，则需要先搜索 k 索引树，然后得到主键 ID 的值为 1，再到 ID 索引树搜索一次。这个过程虽然用了索引，但实际上底层进行了两次索引查询，这个过程就称为回表。
```

注意：

1. 基于非主键索引的查询需要多扫描一颗索引树
2. 使用聚集索引（主键或第一个唯一索引）就不会回表，普通索引可能会回表

### 索引覆盖

1. 索引覆盖：只需要在一颗索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快
2. 触发条件：explain 的输出结果 Extra 字段为 Using index 时，能够触发索引覆盖
3. 实现索引覆盖的方法：将被查询的字段，建立到联合索引里去

**使用案例**

```mysql
create table user (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index (name)
)engine=innodb;
```

```mysql
select id,name from user where name='shenjian';
-- 能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

select id,name,sex from user where name='shenjian';
-- 能够命中name索引，索引叶子节点存储了主键id，没有储存sex，sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫描聚集索引获取sex字段，效率会降低。
```

```mysql
create table user1 (
    id int primary key,
    name varchar(20),
    sex varchar(5),
    index(name, sex)
)engine=innodb;
```

```mysql
select id,name ... where name='shenjian';
select id,name,sex ... where name='shenjian';
-- 单列索升级为联合索引(name, sex)后，索引叶子节点存储了主键id，name，sex，都能够命中索引覆盖，无需回表。
```

### 索引下推（ICP）

![](MySQL进阶（1-索引）/1.png)

索引下推（Index Condition Pushdown，简称 ICP）：指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，它能减少回表查询次数，提高查询效率。

**使用原理**

1. 在没有使用 ICP 的情况下

+ 存储引擎读取索引记录
+ 根据索引中的主键值，定位并读取完整的行记录
+ 存储引擎把记录交给 Server 层去检测该记录是否满足 WHERE 条件

2. 使用 ICP 的情况下

+ 存储引擎读取索引记录（不是完整的行记录）
+ 判断 WHERE 条件部分能否用索引中的列来做检查。条件不满足，则处理下一行索引记录；
+ 条件满足，使用索引中的主键去定位并读取完整的行记录（回表）
+ 存储引擎把记录交给 Server 层，Server 层检测该记录是否满足除 WHERE 条件的其他部分

**使用条件**

1. 只能用于 range、ref、eq_ref、ref_or_null 访问方法；
2. 只能用于 InnoDB 和 MyISAM 存储引擎及其分区表；
3. 对 InnoDB 存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）; 对于 InnoDB 的聚簇索引来说，数据和索引是在一起的，不存在回表这一说。
4. 引用了子查询的条件不能下推；
5. 引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。

**使用案例**

```mysql
-- 检索出表中名字第一个字是张，而且年龄是 10 岁的所有用户
select * from tuser where name like '张%' and age=10;
```

![](MySQL进阶（1-索引）/2.png)

1. 没有使用 ICP

在 MySQL5.6 之前，存储引擎根据通过联合索引找到 name like '张%'的主键 id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server 层再对数据 age = 10 进行筛选。可以看到需要回表两次，浪费了字段 age

![](MySQL进阶（1-索引）/3.png)

2. 使用 ICP

MySQL5.6 以后，存储引擎根据（name，age）联合索引，找到 name like '张%'，由于联合索引中包含 age 列，所以存储引擎直接在联合索引里按照 age = 10 过滤，按照过滤后的数据再一一进行回表扫描，只回表了一次，使用 explain 查询，Extra 列中有 Using index condition

![](MySQL进阶（1-索引）/4.png)

### 前缀索引

指使用字段的前部分字符建立索引，而不是在整个字段上建立索引

1. 优点：可以节省索引的空间，提高索引效率
2. 缺点：降低索引的选择性（不重复数量/总数量），覆盖索引失效，order by 上不能使用前缀索引
3. 使用场景：字段的前部分内容区分度高，后部分区分度低，如：邮箱地址-zhangsan@qq.com

**前缀索引对覆盖索引的影响**

```mysql
select id,email from User where email='zhangsan@xx.com';
select id,name,email from User where email='zhangsan@xx.com';
-- 第一句SQL相比于第二条SQL，只返回了id和email。如果使用email整个字符串作为索引的话，可以利用覆盖索引，从index1查到结果直接返回，不需要回表。但是如果使用前缀索引的话，是需要回表进行判断的。
```

### 自适应哈希索引（AHI）

自适应哈希索引是 Innodb 引擎的一个特殊功能，当它注意到某些索引值使用的非常频繁，发现建立哈希索引（又称散列索引）可以带来速度的提升，Innodb 就会在自己的内存缓冲区（Buffer Pool）里，开辟一块区域，建立自适应哈希索引（Adaptive Hash Index，AHI），以便加速查询。

InnoDB 会进行自调优，如果判定建立哈希索引能够提升查询效率，InnoDB 自己会在内存中建立相关哈希索引（所以这就是 Adaptive——“自适应”的由来），不需要人工手动干预，InnoDB 会根据所需自己创建自适应哈希索引。AHI 是通过缓冲池的 B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。

AHI 有一个要求，即对这个页的连续访问模式必须是一样的，例如：对于(a, b)这样的联合索引页，其访问模式可以是：

1. where a = xxx
2. where a = xxx and b = xxx

访问模式一样指的是查询的条件一样，若交替进行上述两种查询，那么 InnoDB 存储引擎不会对该页造成 AHI

### 底层数据结构

MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。

内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。

磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。

由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。

#### 树的高度

索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 Hash 索引、B+树索引等，经常使用的 InnoDB 存储引擎的默认索引实现为 B+树索引

**增加 B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？**

不可以，因为这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时 B+树的多路存储威力就出来了，可以每次加载 B+树的一个结点，然后一步步往下找

#### 聚簇索引（InnoDB）

聚集索引表记录的排序顺序和索引的排列顺序一致，所以查询速度快，对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序（因为在真实物理存储器的存储顺序只能有一种，而插入新数据必然会导致主键索引树的变化，主键索引树的顺序发生了改变，叶子节点中存储的行数据也要随之进行改变，就会发生大量的数据移动操作，所以效率会慢），因为在物理内存中的顺序只能有一种，所以聚集索引在一个表中只能有一个

聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。他的数据行只存放在索引（B+树）的叶子中，内部节点不存放数据，找到了索引也就找到了数据

![](MySQL进阶（1-索引）/5.png)

特点：

1. 存储数据的顺序和索引顺序一致，一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。
2. 如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替；
3. 如果表中没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引

注意：

1. 数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。
2. B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以 B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次。

#### 非聚簇索引（MyISAM）

非聚簇索引指 B+树的叶子节点上的 data，并不是数据本身，而是主键值，主要用在 MyISAM 存储引擎中。访问数据总是需要二次查找，第一次找到主键值，第二次根据主键值找到行数据

![](MySQL进阶（1-索引）/6.png)

会先检查二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫回表，也就是说要查两个 B+Tree 才能查到数据。

当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作覆盖索引，也就是只需要查一个 B+Tree 就能找到数据

#### 聚簇 VS 非聚簇索引

1. 聚簇索引的叶子节点存储索引值和行数据；非聚簇索引的叶子节点存储索引值和主键值
2. 聚簇索引一个表只能有一个；而非聚簇索引一个表可以存在多个
3. 聚集索引存储记录是物理上连续存在；而非聚集索引是逻辑上的连续，物理存储并不连续
4. 聚集索引的物理存储按照索引排序，是一种索引组织形式，索引的键值逻辑顺序决定了数据行的物理存储顺序；非聚集索引的物理存储不按照索引排序，是普通索引，仅仅是对数据列创建相应的索引，不影响整个表的物理存储顺序

#### Hash VS B+树索引

1. 在查询速度上，如果是等值查询，那么 Hash 索引只需要经过一次 Hash 算法即可找到相应的键值，复杂度为 O(1)，这个前提是键值都是唯一的。如果键值不是唯一的（或存在 Hash 冲突），就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据，这时候复杂度会变成 O(n)，降低了 Hash 索引的查找效率，所以 Hash 索引通常不会用到重复值多的列上，比如性别、年龄
2. Hash 索引是无序的，如果是范围查询检索，这时候 Hash 索引就无法起到作用，即使原先是有序的键值，经过 Hash 算法后也会变成不连续的了。B+tree 索引的叶子节点形成有序链表，便于范围查询
3. Hash 索引无法做 like 'xxx%'这样的部分模糊查询，因为需要对完整 key 进行 Hash 运算定位 bucket。而 B+tree 索引具有最左前缀匹配，可以进行部分模糊查询
4. Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。B+tree 索引的叶子节点形成有序链表，可用于排序
5. Hash 索引不支持多列联合索引，对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引将无法使用

### 索引失效的情况

#### 常用场景

1. 索引列参与表达式计算

```mysql
select 'sname' from 'stu' where 'age'+10=30;——不走索引
select 'sname' from 'stu' where 'age'=30-10;——走索引
```

2. 索引列使用函数运算

```mysql
select 'sname' from 'stu' where left('date',4)<1990;
```

3. 通配符%开头

```mysql
select * from 'manong' where 'uname' like '码农%';——走索引
select * from 'manong' where 'uname' like '%码农';——不走索引
select * from 'manong' where 'uname' like '%码农%';——不走索引
```

4. 查询条件中有 or，即使其中有条件带索引也不会使用，换言之，就是要是使用的所有字段，都必须建立索引

```mysql
select * from dept where dname='xxx' or loc='xx'
```

5. 字符串与数字比较不走索引，如果列类型是字符串，那在查询条件中需要将数据用引号引用起来，否则不走索引（可能发生了索引列的隐式转换）

 ```mysql
 select * from tb1 where name=12;
 ```

6. 反向查询!=、<>、NOT IN、IS NOT NULL 不走索引（IN 是走索引的，不等操作是不走索引的）
7. 使用联合索引查询时，不满足最左前缀原则
8. 正则表达式不使用索引
9. MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引（例如：查询返回数据超过了表的 30%）

#### 最左前缀原则

建立（a, b, c）联合索引时

1. 完全匹配左边的列

```mysql
WHERE A = ? AND B = ? AND C = ?;
-- 能使用索引。因为完全匹配了索引的所有三列，能够充分利用联合索引。
WHERE A = ? AND B = ?;
-- 能使用索引。匹配了索引的前两列 A 和 B，因此可以走索引。
WHERE A = ?;
-- 能使用索引。只匹配了索引的第一列 A，仍然可以走索引。
```

2. 跳过中间的列

```mysql 
WHERE B = ?;
-- 不能使用索引。因为跳过了索引的第一列 A，违反了最左前缀法则。
WHERE A = ? AND C = ?;
-- 能部分使用索引。MySQL 可以利用联合索引的第一列 A，但无法利用 C 列。也就是说，索引只会在 A 上起作用，C 则需要额外扫描。
```

3. 前缀匹配（范围查询）

```mysql
WHERE A = ? AND B > ?;
-- 能使用索引。因为范围查询 B > ? 仍然符合最左前缀法则，因此索引可以被使用，但索引只能用于 A 和 B，无法用于 C。
WHERE A = ? AND B = ? AND C > ?;
-- 能使用索引。完全匹配了 A 和 B，且 C 是范围查询，因此可以走索引，且能利用 C。
```

4. LIKE 模糊查询

```mysql
WHERE A = ? AND B LIKE 'abc%';
-- 能使用索引。因为 LIKE 前面部分是常量，不是以通配符开头，所以索引可以用。
WHERE A = ? AND B LIKE '%abc';
-- 不能使用索引。因为 LIKE 以 % 开头，无法使用索引。
```

5. 只查询部分列

```mysql
WHERE C = ?;
-- 不能使用索引。因为跳过了前面的 A 和 B 列，违反了最左前缀法则。
```

B+树的数据项是复合的数据结构，比如：（name, age, sex）的时候，B+树是按照从左到右的顺序来建立搜索树的，当（小明,22, 男）这样的数据来检索的时候，B+树会优先比较 name 来确定下一步的搜索方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据。但当（22, 男）这样没有 name 数据的时候，B+树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。

**注意**

1. = 和 in 可以乱序

比如：a = 1 and b = 2 and c = 3 建立（a, b, c）索引可以任意顺序，MySQL 的优化器会优化成索引可以识别的形式

2. 最左前缀匹配原则会一直向右匹配直到遇到范围查询（>、<、between、like %）就停止匹配

比如：a = 1 and b = 2 and c > 3 and d = 4，如果建立（a, b, c, d）顺序的索引，d 是用不到索引的。如果建立（a, b, d, c）的索引则都可以用到，a、b、d 的顺序可以任意调整

**使用案例**

1. \> 和 <（select * from t_table where a > 1 and b = 2）

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的。因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量

因此这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。

2. \>= 和 <=（select * from t_table where a > = 1 and b = 2）

虽然在符合 a >= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）

所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

3. between（select * from t_table where a between 2 and 8 and b = 2）

查询条件中 a between 2 and 8 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and = <。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and <）

因此这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

4. like（select * from t_user where name like 'j%' and age = 22）

由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。

虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，但是对于符合 name = j 的二级索引记录的范围里，age 字段的值是「有序」的（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）

所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

#### 模糊查询

在 MySQL 中模糊查询 mobile like '%8765'，这种情况是不能使用索引的，我们可以加入冗余列（MySQL5.7 之后加入了虚拟列，使用虚拟列更合适），如 mobile 为 123456，则 mobile_reverse 存储 654321，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse('%456')即可。reverse 是 MySQL 中的反转函数，这种语句是可以使用索引的

![](MySQL进阶（1-索引）/7.png)

%在前面索引为什么会失效？索引的排序顺序是根据比较字符串的首字母排序的，如果首字母相同，就根据比较第二个字母进行排序，以此类推。在进行模糊查询的时候，如果把%放在了前面，最左的 n 个字母是模糊不定的，无法根据索引的有序性准确地定位到某一个索引，只能进行全表扫描，找出符合条件的数据。

### 文件排序（FileSort）

当对 sql 进行 order by 排序的时候，需要尽可能地使用索引排序，如果无法使用索引排序，mysql 就会使用文件排序

1. 双路排序：先根据相应的条件取出相应的排序字段和可以直接定位行数的行 ID，然后在 sort buffer 中进行排序，排序完后再次取回其他需要的字段
2. 单路排序：一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序

```mysql
select * from user where name="hello" order by age
```

#### 双路排序过程

1. 从索引 name 找到第一个满足 name = "hello" 的主键 id
2. 根据主键 id 取出整行，把排序字段 age 和主键 id 这两个字段放在 sort buffer（排序缓存）中
3. 从索引 name 取下一个满足 name = "hello" 的主键 id
4. 重复 3、4，直到不满足 name = "hello"
5. 对 sort buffer 中的字段 age 和主键 id 按照 age 进行排序
6. 遍历排序好的 id 和字段 age，按照 id 的值回到原表中取出所有字段的值返回给客户端

#### 单路排序过程

1. 从索引 name 找到第一个满足 name = "hello" 条件的主键 id
2. 根据主键 id 取出整行，取出所有字段的值，存入 sort buffer 中
3. 从索引 name 找到下一个满足 name = "hello" 条件的主键 id
4. 重复 2、3，直到不满足 name = "hello"
5. 对 sort buffer 中的数据按照字段 age 进行排序
6. 返回结果给客户端

#### 结论

1. 单路排序会一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序；
2. 双路排序（又叫回表排序模式）是首先取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；

**using index 和 using filesort**

1. using index 是用到了二级索引树，按照索引树的顺序去排序的；
2. using filesort 是没有用到二级索引树的，而是用到了主键索引，他是把整张表的数据加载到内存，去进行一个排序；

因为 using filesort 是拿的主键索引（整张表的数据），而 using index 拿的是二级索引比主键索引相对小太多，所以 using index 效率会快很多。

#### 排序选择

MySQL 通过比较系统变量 max_length_for_sort_data（默认 1024 字节）的大小和需要查询的字段总大小来判断使用哪种排序模式。

1. 如果字段的总长度小于 max_length_for_sort_data，那么使用单路排序模式；
2. 如果字段的总长度大于 max_length_for_sort_data，那么使用双路排序模式。

#### 内存不足怎么处理的？

```mysql
-- 使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的磁盘文件排序
"number_of_tmp_files": 3,                
```

如果为 0，则使用排序缓存区；不为 0，则使用磁盘文件排序；

#### 出现的条件

1. order by 字段不是索引字段
2. order by 字段是索引字段，但是 select 中没有使用覆盖索引，如：select * from user order by age asc;
3. order by 中同时存在 ASC 和 DESC 排序，如：select a, b from user order by a asc, b desc
4. order by 多个字段排序时，不是按照索引顺序进行 order by，即不是按照最左前缀法则
5. order by 语句中索引列使用了表达式，包括函数表达式

### 索引重构

#### 什么时候需要重建索引呢？

1. 表上频繁发生 update，delete 操作
2. 表上发生了 alter table...move 操作（move 操作导致了 rowid 变化）

#### 怎么判断索引是否应该重建？

1. 一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析：

analyze index  index_name validate structure;

2. 在相同的 session 中查询 index_stats 表：

select height, DEL_LF_ROWS/LF_ROWS from index_stats;

当查询的 height >= 4（索引的深度，即从根到叶节点的高度）或 DEL_IF_ROWS/LF_ROWS > 0.2 的情况下，就应该考虑重建该索引

#### 如何重建索引？

1. drop 原索引，然后再创建索引（这种方式相当耗时，一般不建议使用）

```mysql
drop index index_name;
create index index_name on table_name (index_column);
```

2. 直接重建索引（方法较快，建议使用）

```mysql
alter index indexname rebuild;
alter index indexname rebuild online;
```

rebuild 是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建索引项的方法，如果重建索引时有其他用户在对这个表操作，尽量使用带 online 参数来最大限度的减少索引重建时将会出现的任何加锁问题。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不影响原来的索引，利用这种办法可以用来将一个索引移到新的表空间

#### 重建索引的过程

1. Rebuild 以 index fast full scan 或 table full scan（采用哪种方式取决于 cost）读取原索引中的数据来构建一个新的索引，重建过程中有排序操作，rebuild online 执行表扫描获取数据，重建过程中有排序的操作
2. Rebuild 会阻塞 DML 操作，rebuild online 不会阻塞 DML 操作
3. rebuild online 时系统会产生一个 SYS_JOURNAL_xxx 的 IOT 类型的系统临时日志表，所有 rebuild online 时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引中去，然后 drop 掉旧的索引，rebuild online 就完成了

#### 注意事项

1. 执行 rebuild 操作时，需要检查表空间是否足够
2. 虽然说 rebuild online 操作允许 DML 操作，但还是建议在业务不繁忙时段进行
3. Rebuild 操作会产生大量 Redo Log

### 索引长度限制

1. 对于 MyISAM 表，组合索引的长度跟各个列总和长度有关

+ 字符编码为 utf8，组合索引长度和不能超过 333，超过则创建失败。单列索引不能超过 333，如果字符超过 333，则最终创建的是前缀索引（即取前 333 个字节）
+ 字符编码为 latin1，组合索引长度和不能超过 1000，超过则创建失败。单列索引不能超过 1000，超过则最终创建的是前缀索引（即取前 1000 个字节）

2. 对于 InnoDB 表，组合索引的长度跟各列的长度和无关，跟单列的长度有关，且能创建成功

+ 字符编码为 utf8，组合索引长度最大为列数*255，单列索引长度最大为 255
+ 字符编码为 latin1，组合索引长度最大为列数*767，单列索引长度最大为 767

注意：索引的长度跟数据引擎有关，还和字符编码有关
