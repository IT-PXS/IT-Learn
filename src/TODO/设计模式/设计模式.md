---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 七大原则

### 单一职责原则
规定一个类应该有且只有一个引起它变化的原因，否则类应该被拆分。该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费

```java
public interface UserService { 
    public void login(String username, String password);
    public void register(String email, String username, String password);
    public void logError(String msg);
    public void sendEmail(String email);   
}
```

这段代码很显然存在很大的问题，UserService既要负责用户的注册和登录，还要负责日志的记录和邮件的发送，并且后者的行为明显区别于前者。假设我要修改发送邮件的逻辑就得修改这个类，这时候还得回归登录注册逻辑，明显不合理

```java
public interface UserService {
    public void login(String username, String password);
    public void register(String email, String username, String password);
}

public interface LogService {
    public void logError(String msg);
}

public interface EmailService {
    public void sendEmail(String email);
}
```

对于方法，不要把不相关的对象实例作为参数传进来，如果发现某个方法依赖某个不相关的对象，那么这个方法的实现就可能存在问题

```plsql
loadImage(String url, ImageView view) {
// 下载图片，展示图片
}
```

对于loadImage这个方法，参数url是ok的，但是参数ImageView却是不合理的，因为这里做了两个操作，下载图片，展示图片，应该将这个方法再进行拆分

```java
// 下载图片 
loadImage(String url) {

}

// 显示图片
displayImage(String url, ImageView view) {
// 调用 getBitmap (url)  获取图片
// 获取图片后将其设置到 view 中。
}

// 根据 url 获取图片， 
getBitmap(String url) {

}
```

### 开闭原则
一个软件实体应当对扩展开放，对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展

```java
// 矩形
public class Rectangle {
    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }
}

// 面积计算器
public class AreaCalculator {
    public double area(Rectangle shape){
        return shape.getWidth() * shape.getHeight();
    }
}

----------------------------------------------------
这时候又多了一个圆形类，面积计算器得重新修改
// 圆形
public class Circular {
    public double getRadius(){
        return radius;
    }
}

// 面积计算器
public class AreaCalculator {
    public double area(Object shape){
        if(shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.getWidth() * rectangle.getHeight();
        } else if (shape instanceof Circular) {
            Circular circular = (Circular) shape;
            return circular.getRadius() * circular.getRadius() * Math.PI;
        } else {
            throw new RuntimeException("There is no such type.");
        }
    }
}
```

改进版，把计算面积这个公有逻辑变成一个接口

```java
public interface Shape {
    public double getArea();
}

public class Rectangle implements Shape{
    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return getWidth() * getHeight();
    }   
}
```

当需求变更，需要计算圆形面积的时候，我们只需创建一个圆形的类，并实现shape即可

```java
public class Circular implements Shape {
    public double getRadius(){
        return radius;
    }

    public double getArea() {
        return getRadius() * getRadius() * Math.PI;
    }
}
```

### 里氏替换原则
子类可以扩展父类的功能，但不能改变父类原有的功能

1. 子类中可以增加自己特有的方法
2. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类更宽松
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类的方法更严格或相等

```java
public class Bird {
    public void fly() {
        System.out.println("我正在天上飞");
    }
}
```

```java
public class Eagle extends Bird {
    @Override
    public void fly() {
        System.out.println("我正在8000米高空飞翔");
    }
}
```

```java
public class TestLsp {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly();
        //替换成子类Eagle，子类重写了父类Bird的fly方法
        Eagle eagle = new Eagle();
        eagle.fly();
    }
}
```

### 依赖倒置原则
1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象

其核心思想是：要面向接口编程，不要面向实现编程

1. 每个类尽量提供接口或抽象类，或者两者都具备
2. 变量的声明类型尽量是接口或者是抽象类
3. 任何类都不应该从具体类派生
4. 使用继承时尽量遵循里氏替换原则

```java
class Customer {
    public void shopping(ShaoguanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}

-----------------------------------------------
如果该顾客想从另外一家商店购物，就需要修改代码
class Customer {
    public void shopping(WuyuanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```

顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则

解决方法：定义商店的共同接口shop，顾客类面向接口编程

```java
public class DIPtest{
    public static void main(String[] args){
        Customer wang=new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}

//商店
interface Shop{
    public String sell(); //卖
}

//韶关网店
class ShaoguanShop implements Shop{
    public String sell(){
        return "韶关土特产：香菇、木耳……"; 
    } 
}

//婺源网店
class WuyuanShop implements Shop{
    public String sell(){
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 

//顾客
class Customer{
    public void shopping(Shop shop){
        //购物
        System.out.println(shop.sell()); 
    }
}
```

### 接口隔离原则
类间的依赖关系应该建立在最小的接口上，建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用

1. 接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑
2. 为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法
3. 了解环境，拒绝盲从，每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑
4. 提高内聚，减少对外交互，使接口用最少的方法去完成最多的事情

```java
public interface IAnimal {
    void run();
    void swim();
    void fly();
}
```

```java
public class Dog implements IAnimal {
    @Override
    public void run() {
        System.out.println("我跑的很快");
    }

    @Override
    public void swim() {
        System.out.println("我还会游泳");
    }

    @Override
    public void fly() {

    }
}
```

```java
public interface IFlyAnimal {
    void fly();
}
```

```java
public interface IRunAnimal {
    void run();
}
```

```java
public interface ISwimAnimal {
    void swim();
}
```

```java
public class Dog implements IRunAnimal,ISwimAnimal {
    @Override
    public void run() {
        System.out.println("我跑的很快");
    }

    @Override
    public void swim() {
        System.out.println("我还会游用");
    }
}
```

### 迪米特法则
只与你的直接朋友交谈，不跟“陌生人”说话，“朋友”指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用

1. 在类的划分上，应该创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标
2. 在类的结构设计上，尽量降低类成员的访问权限
3. 在类的设计上，优先考虑将一个类设置成不变类
4. 在对其他类的引用上，将引用其他对象的次数降到最低
5. 不暴露类的属性成员，而应该提供相应的访问器（set和get方法）
6. 谨慎使用序列化（Serializable）功能

```java
public class LoDtest{
    public static void main(String[] args){
        Agent agent=new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}

//经纪人
class Agent{
    private Star myStar;
    private Fans myFans;
    private Company myCompany;
    public void setStar(Star myStar){
        this.myStar=myStar;
    }
    public void setFans(Fans myFans){
        this.myFans=myFans;
    }
    public void setCompany(Company myCompany){
        this.myCompany=myCompany;
    }
    public void meeting(){
        System.out.println(myFans.getName()+"与明星"+myStar.getName()+"见面了。");
    }
    public void business(){
        System.out.println(myCompany.getName()+"与明星"+myStar.getName()+"洽淡业务。");
    }
}

//明星
class Star{
    private String name;
    Star(String name){
        this.name=name;
    }
    public String getName(){
        return name;
    }
}

//粉丝
class Fans{
    private String name;
    Fans(String name){
        this.name=name;
    }
    public String getName(){
        return name;
    }
}

//媒体公司
class Company{
    private String name;
    Company(String name){
        this.name=name;
    }
    public String getName(){
        return name;
    }
}
```

### 合成复用原则
指的是在软件复用时，要尽量先使用组合(has-a)或者聚合(contains-a)等关联关系来实现，这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少

## 创建型模式
1. 类创建型模式：只需要知道创建产品的类或类层次结构，就可以创建出相应的对象。调用者只需要看到创建对象的类，而不需要知道自己将会得到什么样的一个对象。
2. 对象创建型模式：调用者通过一个函数来创建对象，所以调用者必须知道自己将要得到什么样的对象，只要知道将要得到对象的特征就行了，将其传给工厂方法来获得要的对象。

### 单例模式（Singleton）
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

例<font style="color:#000000;">如：在windows桌面上打开了一个回收站，当试图再次打开一个新的回收站时，windows系统并不会弹出一个新的回收站，在系统运行的过程中只维护一个回收站的实例。假如每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。</font>

#### <font style="color:rgb(68, 68, 68);">饿汉式（线程安全）</font>
```java
//饿汉式单例
public class Singleton1 {
    //指向自己实例的私有静态引用，主动创建
    private static Singleton1 singleton1=new Singleton1();

    //私有的构造方法
    private Singleton1(){}

    //以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton1 getSingleton1(){
        return singleton1;
    }
}
```

#### 懒汉式（线程不安全）
```java
//懒汉式单例
public class Singleton2 {
    //指向自己实例的私有静态引用
    private static Singleton2 singleton2;

    //私有的构造方法
    private Singleton2(){}

    //以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton2 getSingleton2(){
        //被动创建，在真正需要使用时才去创建
        if (singleton2==null){
            singleton2=new Singleton2();
        }
        return singleton2;
    }
}
```

缺点：单例实例被延迟加载，但是只能在单线程下使用，如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个实例，这时便会产生多个实例，所以在多线程环境下不可使用

#### 懒汉式（线程安全）
```java
//懒汉式单例
public class Singleton2 {
    //指向自己实例的私有静态引用
    private static Singleton2 singleton2;

    //私有的构造方法
    private Singleton2(){}

    //以自己实例为返回值的静态的公有方法，静态工厂方法
    public static synchronized Singleton2 getSingleton2(){
        //被动创建，在真正需要使用时才去创建
        if (singleton2==null){
            singleton2=new Singleton2();
        }
        return singleton2;
    }
}
```

#### 双重加锁机制（线程安全）
<font style="background-color:#FBDE28;">错误的双重检查锁</font>

```java
public class Singleton3 {
    private static Singleton3 instance;

    private Singleton3(){}

    public Singleton3 getInstance(){
        if (instance==null){
            synchronized (Singleton3.class){
                if (instance==null){
                    instance=new Singleton3();//Error
                }
            }
        }
        return instance;
    }
}
```

存在隐患：实例化对象的那行代码（标记为error的那行），实际上可以分解成以下步骤：

1. 给instance分配内存空间
2. 调用Singleton3的构造函数来初始化成员变量
3. 将instance对象指向刚分配的内存空间

但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，顺序就成了：

1. 分配内存空间
2. 将对象指向刚分配的内存空间
3. 初始化对象

![](https://cdn.nlark.com/yuque/0/2022/png/12836966/1648377128580-2f9bf546-57f9-4984-b850-b5a638f1081f.png)

<font style="color:rgb(51, 51, 51);">在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。</font>在这种情况下，T7时刻线程B对uniqueSingleton的访问，访问的是一个初始化未完成的对象。

解决方法：在uniqueSingletion前加上关键字volatile，使用了volatile关键字后，重排序被禁止，所有的写操作都将发生在读操作之前

<font style="background-color:#FBDE28;">正确的双重校验锁</font>

```java
public class Singleton4 {
    private volatile static Singleton4 singleton4;

    private Singleton4(){}

    public Singleton4 getSingleton4(){
        if (singleton4==null){
            synchronized (Singleton4.class){
                if (singleton4==null){
                    singleton4=new Singleton4();
                }
            }
        }
        return singleton4;
    }
}
```

#### 静态内部类（线程安全）
```java
public class Singleton5 {
    
    private Singleton5(){}

    private static class SingletonHolder {
        private static final Singleton5 INSTANCE = new Singleton5();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

当外部类Singleton被加载时，静态内部类SingletionHolder并没有被加载进内存。当调用getUniqueInstance()方法时，触发了SingletonHolder.INSTANCE，此时静态内部类SingletonHolder才会被加载进内存，并且初始化INSTANCE实例，而且JVM会确保INSTANCE只被实例化一次

#### 枚举类（线程安全）
```java
public enum Singleton {
    INSTANCE;

    //添加自己需要的操作
    public void doSomeThing() {
    }
}
```

优点：

1. 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例
2. 枚举类天然防止反序列化，其他单例模式可以通过重写readResolve()方法，从而防止反序列化

```java
private Object readResolve() throws ObjectStreamException{
    return singleton;
}
```

### 原型模式（Prototype）
用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

产生背景：单例模式可以避免重复创建消耗资源的对象，但是却不得不共用对象。若是对象本身也不让随意访问修改时，怎么办？通常做法是备份到副本，其他对象操作副本，最后获取权限合并

#### 浅克隆
1. 新建对象设置属性

```java
public interface IPrototype {
    IPrototype clone();
}
```

```java
@Data
public class PrototypeImplA implements IPrototype{
    private String name;

    private int age;

    private List<String> phoneList;

    @Override
    public IPrototype clone() {
        PrototypeImplA prototypeImplA = new PrototypeImplA();
        prototypeImplA.setAge(this.age);
        prototypeImplA.setName(this.name);
        prototypeImplA.setPhoneList(this.phoneList);
        return prototypeImplA;
    }
}
```

```java
public class ProtoTypeTest {
    public static void main(String[] args) throws Exception {
        PrototypeImplA prototypeImplA = new PrototypeImplA();
        prototypeImplA.setAge(18);
        prototypeImplA.setName("张三");
        List<String> phoneList = new ArrayList<>();
        phoneList.add("88888888");
        phoneList.add("77777777");
        prototypeImplA.setPhoneList(phoneList);

        PrototypeImplA cloneProtoType = (PrototypeImplA) prototypeImplA.clone();
        System.out.println(prototypeImplA.getPhoneList() == cloneProtoType.getPhoneList());//true
    }
}

// 结果：true
```

对象中如果有引用对象那么被克隆后的对象依然会指向原对象，如果需要复制两个独立的对象，则需要使用深克隆

2. 使用clone方法

```java
@Data
public class PrototypeB implements Cloneable {
    private String name;

    private int age;

    private List<String> phoneList;

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public class ProtoTypeTest2 {
    public static void main(String[] args) throws CloneNotSupportedException {
        PrototypeB prototypeImplB = new PrototypeB();
        prototypeImplB.setAge(18);
        prototypeImplB.setName("张三");
        List<String> phoneList = new ArrayList<>();
        phoneList.add("88888888");
        phoneList.add("77777777");
        prototypeImplB.setPhoneList(phoneList);

        PrototypeB cloneProtoTypeB = (PrototypeB)prototypeImplB.clone();
        System.out.println(prototypeImplB.getPhoneList() == cloneProtoTypeB.getPhoneList());//true
    }
}

// 结果：true
```

#### 深克隆
```java
@Data
public class PrototypeB implements Cloneable, Serializable {
    private String name;

    private int age;

    private List<String> phoneList;

    public Object clone() throws CloneNotSupportedException {
        return this.deepClone();
    }

    public PrototypeB deepClone(){
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);

            PrototypeB clone = (PrototypeB)ois.readObject();
            return clone;
        }catch (Exception e){
            return null;
        }
    }
}
```

### 简单工厂模式（静态方法模式）
在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口

应用场景：

1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 
2. Hibernate 换数据库只需换方言和驱动就可以。

```java
//苹果手机
public abstract class ApplePhone {
    //获取尺寸
    public abstract void getSize();
}

public class IphoneX extends ApplePhone{
    @Override
    public void getSize() {
        System.out.println("3.5英寸");
    }
}

public class IphoneXR extends ApplePhone{
    @Override
    public void getSize() {
        System.out.println("5.5英寸");
    }
}

public class IphoneXs extends ApplePhone{
    @Override
    public void getSize() {
        System.out.println("4.5英寸");
    }
}
```

```java
//苹果工厂
public class AppleFactory {
    public static ApplePhone createPhone(String model){
        ApplePhone applePhone=null;
        switch (model){
            case "iPhoneX":
                applePhone=new IphoneX();
                break;
            case "iPhoneXs":
                applePhone=new IphoneXs();
                break;
            case "iPhoneXR":
                applePhone=new IphoneXR();
                break;
        }
        return applePhone;
    }
}

public class Client {
    public static void main(String[] args) {
        ApplePhone applePhone;
        applePhone=AppleFactory.createPhone("iPhoneX");
        applePhone.getSize();
        applePhone=AppleFactory.createPhone("iPhoneXs");
        applePhone.getSize();
        applePhone=AppleFactory.createPhone("iPhoneXR");
        applePhone.getSize();
    }
}
```

1. 优点：将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的分离
2. 缺点：工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且当产品类型较多时，简单工厂的if判断会非常多，不容易维护

### 工厂方法模式（Factory Method）
定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。

使用场景：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

```java
abstract class Product{
    public abstract void Show();
}

//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}
 
//具体产品B类
class  ProductB extends  Product{
 
    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```

```java
abstract class Factory{
    public abstract Product Manufacture();
}

//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}
 
//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```

```java
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();
 
        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```

### 抽象工厂模式（Abstract Factory）
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

使用场景：为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。

![](https://cdn.nlark.com/yuque/0/2022/jpeg/12836966/1657376482928-a2063346-18b9-48bc-b440-b048928b2785.jpeg)

```java
public interface Human {
    //打印肤色
    public void printColor();
}

public abstract class Man implements Human{
    public void printGender(){
        System.out.println("性别为男");
    }

    public abstract void printColor();
}

public abstract class Woman implements Human{
    public void printGender(){
        System.out.println("性别为女");
    }

    public abstract void printColor();
}
```

```java
public class BlackMan extends Man{
    @Override
    public void printColor() {
        System.out.println("黑皮肤");
    }
}
public class BlackWoman extends Woman{
    @Override
    public void printColor() {
        System.out.println("黑皮肤");
    }
}

public class WhiteMan extends Man{
    @Override
    public void printColor() {
        System.out.println("白皮肤");
    }
}
public class WhiteWoman extends Woman{
    @Override
    public void printColor() {
        System.out.println("白皮肤");
    }
}

public class YellowMan extends Man{
    @Override
    public void printColor() {
        System.out.println("黄皮肤");
    }
}
public class YellowWoman extends Woman{
    @Override
    public void printColor() {
        System.out.println("黄皮肤");
    }
}
```

```java
public abstract class HumanFactory {
    //创建男人
    public abstract Man createMan();
    //创建女人
    public abstract Woman createWoman();
}

public class BlackHumanFactory extends HumanFactory{
    @Override
    public Man createMan() {
        return new BlackMan();
    }

    @Override
    public Woman createWoman() {
        return new BlackWoman();
    }
}

public class WhiteHumanFactory extends HumanFactory{
    @Override
    public Man createMan() {
        return new WhiteMan();
    }

    @Override
    public Woman createWoman() {
        return new WhiteWoman();
    }
}

public class YellowHumanFactory extends HumanFactory{
    @Override
    public Man createMan() {
        return new YellowMan();
    }

    @Override
    public Woman createWoman() {
        return new YellowWoman();
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        HumanFactory factory = null;
        //创建黑人
        factory = new BlackHumanFactory();
        Man blackMan = factory.createMan();
        blackMan.printGender();
        blackMan.printColor();
        Woman blackWoman = factory.createWoman();
        blackWoman.printGender();
        blackWoman.printColor();
    }
}
```

### 构建器模式（Bulider）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

```java
public class User {

    private final String firstName;     // 必传参数
    private final String lastName;      // 必传参数
    private final int age;              // 可选参数
    private final String phone;         // 可选参数
    private final String address;       // 可选参数

    public User(String firstName, String lastName) {
        this(firstName, lastName, 0);
    }

    public User(String firstName, String lastName, int age) {
        this(firstName, lastName, age, "");
    }

    public User(String firstName, String lastName, int age, String phone) {
        this(firstName, lastName, age, phone, "");
    }

    public User(String firstName, String lastName, int age, String phone, String address) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
        this.phone = phone;
        this.address = address;
    }
}
```

这样虽然可以运行，但是有以下缺点：

1. 参数多时将很麻烦
2. 对于只想传一个参数，且参数位置在后边，如传入address，那么只能采用最后一个构造方法，且需对前几个参数赋值，这是耗时且不必要的操作。

使用Setter和Getter的缺点：

1. 对象会产生不一致的状态。当你想要传入5个参数的时候，你必需将所有的setXX方法调用完成之后才行。然而一部分的调用者看到了这个对象后，以为这个对象已经创建完毕，就直接使用了，其实User对象并没有创建完成。
2. 类是可变的了，不可变类所有好处都不复存在。

```java
public class User {

    private final String firstName;     // 必传参数
    private final String lastName;      // 必传参数
    private final int age;              // 可选参数
    private final String phone;         // 可选参数
    private final String address;       // 可选参数

    private User(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.phone = builder.phone;
        this.address = builder.address;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public int getAge() {
        return age;
    }

    public String getPhone() {
        return phone;
    }

    public String getAddress() {
        return address;
    }

    public static class UserBuilder {
        private final String firstName;
        private final String lastName;
        private int age;
        private String phone;
        private String address;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public UserBuilder address(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

这种方式有以下优点：

1. 类的构造方法是私有的。也就是说调用者不能直接创建User对象。
2. 类的属性都是不可变的。所有的属性都添加了final修饰符，并且在构造方法中设置了值。并且，对外只提供getters方法。
3. Builder的内部类构造方法中只接收必传的参数，并且该必传的参数适用了final修饰符。

## 结构型模式
### 代理模式（Proxy）
给某一个对象提供一个代理，并由代理对象控制原对象的引用

```java
//抽象主题
public interface Subject {
    void Request();
}

//真实主题
public class RealSubject implements Subject{
    @Override
    public void Request() {
        System.out.println("访问真实主题方法");
    }
}
```

```java
//代理
public class Proxy implements Subject{
    private RealSubject realSubject;

    @Override
    public void Request() {
        if (realSubject==null){
            realSubject=new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }

    public void preRequest(){
        System.out.println("访问真实主题之前的预处理");
    }

    public void postRequest(){
        System.out.println("访问真实主题之后的预处理");
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.Request();
    }
}
```

### 享元模式（Flyweight）
共享元对象，运用共享技术有效地支持大量细粒度对象的复用。如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用创建新的对象

```java
public interface Shape {
    void draw();
}

@Data
public class Circle implements Shape{
    private String color;
    private int x;
    private int y;
    private int radius;
}
```

```java
public class ShapeFactory {
    private static final HashMap<String,Shape>circleMap=new HashMap<>();

    public static Shape getCircle(String color){
        Circle circle=(Circle) circleMap.get(color);

        if (circle==null){
            circle=new Circle(color);
            circleMap.put(color,circle);
            System.out.println("Creating circle of color:"+color);
        }
        return circle;
    }
}
```

```java
public class FlyweightPatternDemo {
    private static final String colors[]=
            {"Red","Green","Blue","White","Black"};

    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            Circle circle=(Circle)ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
    }

    private static String getRandomColor(){
        return colors[(int)(Math.random()*colors.length)];
    }

    private static int getRandomX(){
        return (int)(Math.random()*100);
    }

    private static int getRandomY(){
        return (int)(Math.random()*100);
    }
}
```

### 组合模式（Composite）
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

```java
public class Employee {
    private String name;
    private String dept;
    private int salary;
    private List<Employee> subordinates;

    public Employee(String name,String dept,int sal){
        this.name=name;
        this.dept=dept;
        this.salary=sal;
        subordinates=new ArrayList<>();
    }

    public void add(Employee e){
        subordinates.add(e);
    }

    public void remove(Employee e){
        subordinates.remove(e);
    }

    public List<Employee> getSubordinates(){
        return subordinates;
    }

    public String toString(){
        return ("Employee :[ Name :"+name+
                ", dept :"+dept+", salary :"
                +salary+" ]");
    }
}
```

```java
public class CompositePatternDemo {
    public static void main(String[] args) {
        Employee CEO = new Employee("John", "CEO", 30000);
        Employee headSales = new Employee("Robert", "Head Sales", 20000);
        Employee headMarketing = new Employee("Michel", "Head Marketing", 20000);
        Employee clerk1 = new Employee("Laura", "Marketing", 10000);
        Employee clerk2 = new Employee("Bob", "Marketing", 10000);
        Employee salesExecutive1 = new Employee("Richard", "Sales", 10000);
        Employee salesExecutive2 = new Employee("Rob", "Sales", 10000);

        CEO.add(headSales);
        CEO.add(headMarketing);

        headSales.add(salesExecutive1);
        headSales.add(salesExecutive2);

        headMarketing.add(clerk1);
        headMarketing.add(clerk2);

        System.out.println(CEO);
        for (Employee subordinate : CEO.getSubordinates()) {
            System.out.println(subordinate);
            for (Employee subordinateSubordinate : subordinate.getSubordinates()) {
                System.out.println(subordinateSubordinate);
            }
        }
    }
}
```

### 桥接模式（Bridge）
将抽象部分与它的实现部分分离，使他们都可以独立地变化

```java
public interface DrawAPI {
    public void drawCircle(int radius,int x,int y);
}

public class GreenCircle implements DrawAPI{
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Circle[ color: green, radius: "+radius+",x: "+x+", "+y+"]");
    }
}

public class RedCircle implements DrawAPI{
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Circle[ color: red, radius: "+radius+",x: "+x+", "+y+"]");
    }
}
```

```java
public abstract class Shape {
    protected DrawAPI drawAPI;
    protected Shape(DrawAPI drawAPI){
        this.drawAPI=drawAPI;
    }
    public abstract void draw();
}

public class Circle extends Shape{
    private int x,y,radius;

    public Circle(int x,int y,int radius,DrawAPI drawAPI){
        super(drawAPI);
        this.x=x;
        this.y=y;
        this.radius=radius;
    }

    @Override
    public void draw() {
        drawAPI.drawCircle(radius,x,y);
    }
}
```

```java
public class BridgePatternDemo {
    public static void main(String[] args) {
        Shape redCircle=new Circle(100,100,10,new RedCircle());
        Shape greenCircle=new Circle(100,100,10,new GreenCircle());

        redCircle.draw();
        greenCircle.draw();
    }
}
```

### 装饰器模式（Decorator）
动态地给一个对象添加一些额外的职责，同时又不改变其结构

+ 使用场景：孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 

```java
public interface Shape {
    void draw();
}

public class Rectangle implements Shape{
    @Override
    public void draw() {
        System.out.println("Shape: Rectangle");
    }
}

public class Circle implements Shape{
    @Override
    public void draw() {
        System.out.println("Shape: Circle");
    }
}
```

```java
public abstract class ShapeDecorator implements Shape{
    protected Shape decoratedShape;

    public ShapeDecorator(Shape decoratedShape){
        this.decoratedShape = decoratedShape;
    }

    public void draw(){
        decoratedShape.draw();
    }
}

public class RedShapeDecorator extends ShapeDecorator{
    public RedShapeDecorator(Shape decoratedShape) {
        super(decoratedShape);
    }

    @Override
    public void draw() {
        decoratedShape.draw();
        setRedBorder(decoratedShape);
    }

    protected void setRedBorder(Shape decoratedShape){
        System.out.println("Border Color: Red");
    }
}
```

```java
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Shape circle=new Circle();
        ShapeDecorator redCircle=new RedShapeDecorator(new Circle());
        ShapeDecorator redRectangle=new RedShapeDecorator(new Rectangle());

        System.out.println("Circle with normal border");
        circle.draw();

        System.out.println("\nCircle of red border");
        redCircle.draw();

        System.out.println("\nRectangle of red border");
        redRectangle.draw();
    }
}
```

### 外观模式（Facade）
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

```java
public interface Shape {
    void draw();
}

public class Rectangle implements Shape{
    @Override
    public void draw() {
        System.out.println("Rectangle::draw()");
    }
}

public class Square implements Shape{
    @Override
    public void draw() {
        System.out.println("Square::draw()");
    }
}

public class Circle implements Shape{
    @Override
    public void draw() {
        System.out.println("Circle::draw()");
    }
}
```

```java
public class ShapeMaker {
    private Shape circle;
    private Shape rectangle;
    private Shape square;

    public ShapeMaker(){
        circle=new Circle();
        rectangle=new Rectangle();
        square=new Square();
    }

    public void drawCircle(){
        circle.draw();
    }

    public void drawRectangle(){
        rectangle.draw();
    }

    public void drawSquare(){
        square.draw();
    }
}
```

```java
public class FacadePatternDemo {
    public static void main(String[] args) {
        ShapeMaker shapeMaker=new ShapeMaker();

        shapeMaker.drawCircle();
        shapeMaker.drawRectangle();
        shapeMaker.drawSquare();
    }
}
```

### 适配器模式（Adapter）
将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 

#### 默认适配器模式
```java
public interface FileAlterationListener {  
    void onStart(final FileAlterationObserver observer);  
    void onDirectoryCreate(final File directory);  
    void onDirectoryChange(final File directory);  
    void onDirectoryDelete(final File directory);  
    void onFileCreate(final File file);  
    void onFileChange(final File file);  
    void onFileDelete(final File file);  
    void onStop(final FileAlterationObserver observer);  
}  
```

此接口的一大问题是抽象方法太多了，如果要用这个接口，意味着要实现每一个抽象方法，如果只是想要监控文件夹中的文件创建和文件删除事件，可是还是不得不实现所有的方法，很明显，这不是期望的。

所以，需要下面的一个适配器，它用于实现上面的接口，但是所有的方法都是空方法，这样，就可以转而定义自己的类来继承下面这个类即可。

```java
public class FileAlterationListenerAdaptor implements FileAlterationListener {  
  
    public void onStart(final FileAlterationObserver observer) {  
    }  
  
    public void onDirectoryCreate(final File directory) {  
    }  
  
    public void onDirectoryChange(final File directory) {  
    }  
  
    public void onDirectoryDelete(final File directory) {  
    }  
  
    public void onFileCreate(final File file) {  
    }  
  
    public void onFileChange(final File file) {  
    }  
  
    public void onFileDelete(final File file) {  
    }  
  
    public void onStop(final FileAlterationObserver observer) {  
    }  
}  
```

```java
public class FileMonitor extends FileAlterationListenerAdaptor {  
    public void onFileCreate(final File file) {  
        // 文件创建  
        doSomething();  
    }  
  
    public void onFileDelete(final File file) {  
        // 文件删除  
        doSomething();  
    }  
}  
```

#### 对象适配器模式
```java
public interface Duck {  
    public void quack(); // 鸭的呱呱叫  
    public void fly(); // 飞  
}  
  
public interface Cock {  
    public void gobble(); // 鸡的咕咕叫  
    public void fly(); // 飞  
}  
  
public class WildCock implements Cock {  
    public void gobble() {  
        System.out.println("咕咕叫");  
    }  
    public void fly() {  
        System.out.println("鸡也会飞哦");  
    }  
}  
```

```java
// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用  
public class CockAdapter implements Duck {  
  
    Cock cock;  
    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用  
    public CockAdapter(Cock cock) {  
        this.cock = cock;  
    }  
  
    // 实现鸭的呱呱叫方法  
    @Override  
    public void quack() {  
        // 内部其实是一只鸡的咕咕叫  
        cock.gobble();  
    }  
  
    @Override  
    public void fly() {  
        cock.fly();  
    }  
}  
```

```java
public static void main(String[] args) {  
    // 有一只野鸡  
      Cock wildCock = new WildCock();  
      // 成功将野鸡适配成鸭  
      Duck duck = new CockAdapter(wildCock);  
      ...  
}  
```

#### 类适配器模式
![](https://cdn.nlark.com/yuque/0/2021/webp/396745/1639464186165-140e1944-b6cb-47b6-8209-5d747522e76f.webp?x-oss-process=image%2Fresize%2Cw_1080%2Climit_0)

## 行为型模式
### 状态模式（State）
允许一个对象在其内部状态改变时改变它的行为

例如：<font style="color:rgb(51, 51, 51);">打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</font>

```java
public interface State {
    public void doAction(Context context);
}

public class StartState implements State{

    @Override
    public void doAction(Context context) {
        System.out.println("Player is in start state");
        context.setState(this);
    }

    public String toString(){
        return "Start State";
    }
}

public class StopState implements State{

    @Override
    public void doAction(Context context) {
        System.out.println("Player is in stop state");
        context.setState(this);
    }

    public String toString(){
        return "Stop State";
    }
}
```

```java
public class Context {
    private State state;

    public Context(){
        state=null;
    }

    public void setState(State state){
        this.state=state;
    }

    public State getState(){
        return state;
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        Context context = new Context();

        StartState startState = new StartState();
        startState.doAction(context);
        System.out.println(context.getState().toString());

        StopState stopState = new StopState();
        stopState.doAction(context);
        System.out.println(context.getState().toString());
    }
}
```

### 策略模式（Strategy）
使用时必须首先创建一个想使用的类对象，然后将该对象作为参数传递进去，调用该对象调用不同的算法

```java
//抽象策略类
public interface Strategy {
    public void strategyMethod();//策略方法
}

public class ConcreteStrategyA implements Strategy{
    @Override
    public void strategyMethod() {
        System.out.println("策略A");
    }
}

public class ConcreteStrategyB implements Strategy{
    @Override
    public void strategyMethod() {
        System.out.println("策略B");
    }
}
```

```java
public class Context {
    private Strategy strategy;

    public Strategy getStrategy(){
        return strategy;
    }

    public void setStrategy(Strategy strategy){
        this.strategy=strategy;
    }

    public void strategyMethod(){
        strategy.strategyMethod();
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        Context context=new Context();
        Strategy strategy=new ConcreteStrategyA();
        context.setStrategy(strategy);
        context.strategyMethod();

        strategy=new ConcreteStrategyB();
        context.setStrategy(strategy);
        context.strategyMethod();
    }
}
```

在简单工厂模式中实现了通过条件选取一个类实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作

策略模式与状态模式的区别：

1. 状态模式重点在各状态之间的切换，从而做不同的事情；而策略模式更侧重于根据具体情况选择策略，并不涉及切换
2. 状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如，聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付，也就是说它们之间是可替换的。而状态模式，各个状态的同一方法做的是不同的事，不能互相替换

### 观察者模式（Observer）
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新

```java
public class Subject {
    private List<Observer> observers=new ArrayList<>();
    private int state;

    public int getState(){
        return state;
    }

    public void setState(int state){
        this.state=state;
        notifyAllObservers();
    }

    //增加观察者
    public void attach(Observer observer){
        observers.add(observer);
    }

    //通知所有观察者
    public void notifyAllObservers(){
        for (Observer observer : observers) {
            observer.update();
        }
    }
}
```

```java
public abstract class Observer {
    protected Subject subject;
    public abstract void update();
}

public class BinaryObserver extends Observer{

    public BinaryObserver(Subject subject){
        this.subject=subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println("Binary String:"+Integer.toBinaryString(subject.getState()));
    }
}

public class OctalObserver extends Observer{

    public OctalObserver(Subject subject){
        this.subject=subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println("Octal String:"+Integer.toOctalString(subject.getState()));
    }
}

public class HexObserver extends Observer{

    public HexObserver(Subject subject){
        this.subject=subject;
        this.subject.attach(this);
    }

    @Override
    public void update() {
        System.out.println("Hex String:"+Integer.toHexString(subject.getState()).toUpperCase());
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        //被观察者
        Subject subject = new Subject();

        //观察者
        new HexObserver(subject);
        new OctalObserver(subject);
        new BinaryObserver(subject);

        System.out.println("First state:15");
        subject.setState(15);
        System.out.println();
        System.out.println("Second state:10");
        subject.setState(10);
    }
}
```

### 模板方法模式（Template Method）
一个抽象类公开定义了执行它的方法的方式/模板，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

```java
public abstract class Game {
    //一些抽象行为放到子类去实现
    abstract void initialize();
    abstract void startPlay();
    abstract void endPlay();

    //模板方法，给出了逻辑的骨架，而逻辑的组成是一些相应的抽象操作
    //它们都推迟到子类实现
    public final void play(){
        //初始化游戏
        initialize();
        //开始游戏
        startPlay();
        //结束游戏
        endPlay();
    }
}
```

```java
public class Cricket extends Game{
    @Override
    void initialize() {
        System.out.println("Cricket Game Initialized!");
    }

    @Override
    void startPlay() {
        System.out.println("Cricket Game started!");
    }

    @Override
    void endPlay() {
        System.out.println("Cricket Game end!");
    }
}

public class Football extends Game{
    @Override
    void initialize() {
        System.out.println("Football Game initialized!");
    }

    @Override
    void startPlay() {
        System.out.println("Football Game start!");
    }

    @Override
    void endPlay() {
        System.out.println("Football Game end!");
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        Game game=new Cricket();
        game.play();

        game=new Football();
        game.play();
    }
}
```

### 责任链模式（Chain of Responsibility）
客户端发出一个请求，链上的对象都有机会来处理这一请求，而客户端不需要知道谁是具体的处理对象。使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止，其过程实际上是一个递归调用

![](https://cdn.nlark.com/yuque/0/2022/jpeg/12836966/1648480192833-ac85dc71-9833-4789-a3b0-5ed250e01bbd.jpeg)

```java
public abstract class AbstractLogger {
    public static int INFO=1;
    public static int DEBUG=2;
    public static int ERROR=3;

    protected int level;

    //责任链中的下一个元素
    protected AbstractLogger nextLogger;

    public void setNextLogger(AbstractLogger nextLogger){
        this.nextLogger=nextLogger;
    }

    public void logMessage(int level,String message){
        if (this.level<=level){
            write(message);
        }
        if (nextLogger!=null){
            nextLogger.logMessage(level,message);
        }
    }

    protected abstract void write(String message);
}
```

```java
public class ConsoleLogger extends AbstractLogger{

    public ConsoleLogger(int level){
        this.level=level;
    }

    @Override
    protected void write(String message) {
        System.out.println("Standard Console::Logger: "+message);
    }
}

public class ErrorLogger extends AbstractLogger{

    public ErrorLogger(int level){
        this.level=level;
    }

    @Override
    protected void write(String message) {
        System.out.println("Error Console::Logger: "+message);
    }
}

public class FileLogger extends AbstractLogger{

    public FileLogger(int level){
        this.level=level;
    }

    @Override
    protected void write(String message) {
        System.out.println("File::Logger: "+message);
    }
}
```

```java
public class ChainPatternDemo {

    private static AbstractLogger getChainOfLoggers(){
        AbstractLogger errorLogger=new ErrorLogger(AbstractLogger.ERROR);
        AbstractLogger fileLogger=new FileLogger(AbstractLogger.DEBUG);
        AbstractLogger consoleLogger=new ConsoleLogger(AbstractLogger.INFO);

        errorLogger.setNextLogger(fileLogger);
        fileLogger.setNextLogger(consoleLogger);
        return errorLogger;
    }

    public static void main(String[] args) {
        AbstractLogger loggerChain=getChainOfLoggers();
        loggerChain.logMessage(AbstractLogger.INFO,"This is an information");
        System.out.println("---------------------------");
        loggerChain.logMessage(AbstractLogger.DEBUG,"This is a debug level information");
        System.out.println("---------------------------");
        loggerChain.logMessage(AbstractLogger.ERROR,"This is an error information");
    }
}
```

### 迭代器模式（Iterator）
提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示

```java
public interface Iterator {
    public boolean hasNext();
    public Object next();
}

public interface Container {
    public Iterator getIterator();
}
```

```java
public class NameRepository implements Container {
    public String[] names = {"Robert", "John", "Julie", "Lora"};

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {
        int index;

        @Override
        public boolean hasNext() {
            if (index < names.length) {
                return true;
            }
            return false;
        }

        @Override
        public Object next() {
            if (this.hasNext()) {
                return names[index++];
            }
            return null;
        }
    }
}
```

```java
public class IteratorPatternDemo {
    public static void main(String[] args) {
        NameRepository nameRepository = new NameRepository();
        for (Iterator iter=nameRepository.getIterator(); iter.hasNext();){
            String name=(String) iter.next();
            System.out.println("Name : "+name);
        }
    }
}
```

### 命令模式（Command）
将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能

```java
public class Stock {
    private String name="ABC";
    private int quantity=10;

    public void buy(){
        System.out.println("Stock [ Name:"+name+","+"Quantity:"+quantity+"]bought");
    }

    public void sell(){
        System.out.println("Stock [ Name:"+name+","+"Quantity:"+quantity+"]sold");
    }
}
```

```java
public interface Order {
    void execute();
}

public class SellStock implements Order{
    private Stock stock;

    public SellStock(Stock stock){
        this.stock=stock;
    }

    @Override
    public void execute() {
        stock.sell();
    }
}

public class BuyStock implements Order{
    private Stock stock;

    public BuyStock(Stock stock){
        this.stock=stock;
    }

    @Override
    public void execute() {
        stock.buy();
    }
}
```

```java
public class Broker {
    private List<Order> orderList=new ArrayList<>();

    public void takeOrder(Order order){
        orderList.add(order);
    }

    public void placeOrders(){
        for (Order order : orderList) {
            order.execute();
        }
        orderList.clear();
    }
}
```

```java
public class Demo {
    public static void main(String[] args) {
        Stock stock = new Stock();

        BuyStock buyStock = new BuyStock(stock);
        SellStock sellStock = new SellStock(stock);

        Broker broker = new Broker();
        broker.takeOrder(buyStock);
        broker.takeOrder(sellStock);
        broker.placeOrders();
    }
}
```

### 解释器模式（Interpreter）
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

```java
public interface Expression {
    public boolean interpret(String context);
}

public class TerminalExpression implements Expression{
    private String data;

    public TerminalExpression(String data){
        this.data=data;
    }

    @Override
    public boolean interpret(String context) {
        if (context.contains(data)){
            return true;
        }
        return false;
    }
}
```

```java
public class AndExpression implements Expression{
    private Expression expr1=null;
    private Expression expr2=null;

    public AndExpression(Expression expr1,Expression expr2){
        this.expr1=expr1;
        this.expr2=expr2;
    }

    @Override
    public boolean interpret(String context) {
        return expr1.interpret(context)&& expr2.interpret(context);
    }
}

public class OrExpression implements Expression{
    private Expression expr1=null;
    private Expression expr2=null;

    public OrExpression(Expression expr1,Expression expr2){
        this.expr1=expr1;
        this.expr2=expr2;
    }

    @Override
    public boolean interpret(String context) {
        return expr1.interpret(context)||expr2.interpret(context);
    }
}
```

```java
public class InterpreterPatternDemo {

    //规则：Robert和John是男性
    public static Expression getMaleExpression(){
        Expression robert=new TerminalExpression("Robert");
        Expression john=new TerminalExpression("John");
        return new OrExpression(robert,john);
    }

    //规则：Julie是一个已婚的女性
    public static Expression getMarredWomanExpression(){
        Expression julie=new TerminalExpression("Julie");
        Expression married=new TerminalExpression("Married");
        return new AndExpression(julie,married);
    }

    public static void main(String[] args) {
        Expression isMale=getMaleExpression();
        Expression isMarriedWoman=getMarredWomanExpression();
        System.out.println("John is male? "+isMale.interpret("John"));
        System.out.println("Julie is a married women? "+isMarriedWoman.interpret("Married Julie"));
    }
}
```

### 中介者模式（Mediator）
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

例如：<font style="color:rgb(51, 51, 51);">中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易</font>

```java
public class ChatRoom {
    public static void showMessage(User user,String message){
        System.out.println(new Date().toString()+" ["+user.getName()+"] : "+message);
    }
}
```

```java
public class User {
    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name=name;
    }

    public User(String name){
        this.name=name;
    }

    public void sendMessage(String message){
        ChatRoom.showMessage(this,message);
    }
}
```

```java
public class MediatorPattern {
    public static void main(String[] args) {
        User robert = new User("Robert");
        User john = new User("John");

        robert.sendMessage("Hi! John!");
        john.sendMessage("Hello! Robert");
    }
}
```

### 访问者模式（Visitor）
表示一个作用于其对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作

例如：<font style="color:rgb(51, 51, 51);">您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</font>

```java
public interface ComputerPart {
    public void accept(ComputerPartVisitor computerPartVisitor);
}

public class Keyboard implements ComputerPart{
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}

public class Monitor implements ComputerPart{
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}

public class Mouse implements ComputerPart{
    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        computerPartVisitor.visit(this);
    }
}

public class Computer implements ComputerPart{
    ComputerPart[] parts;

    public Computer(){
        parts=new ComputerPart[]{new Mouse(),new Keyboard(),new Monitor()};
    }

    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) {
        for (int i = 0; i < parts.length; i++) {
            parts[i].accept(computerPartVisitor);
        }
        computerPartVisitor.visit(this);
    }
}
```

```java
public interface ComputerPartVisitor {
    public void visit(Computer computer);
    public void visit(Mouse mouse);
    public void visit(Keyboard keyboard);
    public void visit(Monitor monitor);
}

public class ComputerPartDisplayVisitor implements ComputerPartVisitor{
    @Override
    public void visit(Computer computer) {
        System.out.println("Displaying Computer");
    }

    @Override
    public void visit(Mouse mouse) {
        System.out.println("Displaying Mouse");
    }

    @Override
    public void visit(Keyboard keyboard) {
        System.out.println("Displaying Keyboard");
    }

    @Override
    public void visit(Monitor monitor) {
        System.out.println("Displaying Monitor");
    }
}
```

```java
public class VisitorPatternDemo {
    public static void main(String[] args) {
        ComputerPart computerPart=new Computer();
        computerPart.accept(new ComputerPartDisplayVisitor());
    }
}
```

### 备忘录模式（Memento）
在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态。备忘录实现的方式需要保证被保存的对象状态不能被对象从外部访问

```java
public class Memento {
    private String state;

    public Memento(String state){
        this.state=state;
    }

    public String getState(){
        return state;
    }
}
```

```java
public class Originator {
    private String state;

    public void setState(String state){
        this.state=state;
    }

    public String getState(){
        return state;
    }

    public Memento saveStateToMemento(){
        return new Memento(state);
    }

    public void getStateFromMemento(Memento memento){
        state=memento.getState();
    }
}
```

```java
public class CareTaker {
    private List<Memento> mementoList=new ArrayList<>();

    public void add(Memento memento){
        mementoList.add(memento);
    }

    public Memento get(int index){
        return mementoList.get(index);
    }
}
```

```java
public class MementoPatternDemo {
    public static void main(String[] args) {
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState("State #1");
        originator.setState("State #2");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #3");
        careTaker.add(originator.saveStateToMemento());
        originator.setState("State #4");

        System.out.println("Current State: "+originator.getState());
        originator.getStateFromMemento(careTaker.get(0));
        System.out.println("First saved State: "+originator.getState());
        originator.getStateFromMemento(careTaker.get(1));
        System.out.println("Second saved State: "+originator.getState());
    }
}
```



