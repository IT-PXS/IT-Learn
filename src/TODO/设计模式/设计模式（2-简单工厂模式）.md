---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 基本介绍

描述：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口

应用场景：

1. 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 
2. Hibernate 换数据库只需换方言和驱动就可以。

![](设计模式（2-简单工厂模式）/1.jpg)

## 使用案例

```java
public interface ICourse {
    // 录制视频
    public void record();
}

public class JavaCourse implements ICourse {
    
    @Override
    public void record() {
        System.out.println("录制Java课程");
    }
}

public class PythonCourse implements ICourse {
    
    @Override
    public void record() {
        System.out.println("录制Python课程");
    }
}
```

```java
public class CourseFactory {
    
    public ICourse create(String name) { 
        if("java".equals(name)) {
            return new JavaCourse();
        } else if("python".equals(name)) {
            return new PythonCourse();
        } else {
            return null;
        }
    }
}
```

```java
public class SimpleFactoryTest {
    
    public static void main(String[] args) {
        CourseFactory factory = new CourseFactory();
        factory.create("java");
    }
}
```

1. 优点：将对象的创建交给专门的工厂类负责，实现了对象的创建和对象的分离
2. 缺点：工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且当产品类型较多时，简单工厂的 if 判断会非常多，不容易维护

客户端调用虽然简单了，但如果业务继续扩展，要增加其他课程，则工厂中的 create()方法就要随着产品链的丰富每次都要修改代码逻辑，这不符合开闭原则。因此可以采用反射技术继续对简单工厂模式进行优化

```java
public class CourseFactory {
    
    public ICourse create(String className){
        try {
            if (!(null == className || "".equals(className))) {
                return (ICourse) Class.forName(className).newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

```java
public class SimpleFactoryTest {
    
    public static void main(String[] args) {
        CourseFactory factory = new CourseFactory();
        ICourse course = factory.create("com.gupaoedu.vip.pattern.factory.simplefactory.JavaCourse");
        course.record();
    }
}
```

优化之后，产品不断丰富，不需要修改 CourseFactory 中的代码。但问题是，方法参数是字符串，可控性有待提升，而且还需要强制转型。

```java
public class CourseFactory {
    
    public ICourse create(Class<? extends ICourse> clazz) {
        try {
            if (null != clazz) {
                return clazz.newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

```java
public class SimpleFactoryTest {
    
    public static void main(String[] args) {
        CourseFactory factory = new CourseFactory();
        ICourse course = factory.create(JavaCourse.class);
        course.record();
    }
}
```

## JDK 源码中的应用

```java
private static Calendar createCalendar(TimeZone zone, Locale aLocale) {
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                             .getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
        }
    }

    Calendar cal = null;
    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType("ca");
        if (caltype != null) {
            switch (caltype) {
                case "buddhist":
                    cal = new BuddhistCalendar(zone, aLocale);
                    break;
                case "japanese":
                    cal = new JapaneseImperialCalendar(zone, aLocale);
                    break;
                case "gregory":
                    cal = new GregorianCalendar(zone, aLocale);
                    break;
            }
        }
    }
    if (cal == null) {
        if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                   && aLocale.getCountry() == "JP") {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}
```

## Logback 源码中的应用

```java
public final class LoggerFactory {
    
    public static Logger getLogger(String name) {
        ILoggerFactory iLoggerFactory = getILoggerFactory();
        return iLoggerFactory.getLogger(name);
    }

    public static Logger getLogger(Class clazz) {
        Logger logger = getLogger(clazz.getName());
        // .....
        return logger;
    }
}
```

