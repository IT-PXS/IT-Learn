---
title: JVM（5-垃圾收集器）
series: JVM
tags:
  - JVM
categories: Java
cover: /img/index/
top_img: /img/index/
published: false
abbrlink: 48844
date: 2024-12-09 22:38:34
description: 
---

## 垃圾收集器

![](JVM（5-垃圾收集器）/2.png)

| 收集器            | 串行、并行、并发 | 新生代/老年代  | 算法           | 目标         | 使用场景                                  |
| ----------------- | ---------------- | -------------- | -------------- | ------------ | ----------------------------------------- |
| Serial            | 串行             | 新生代         | 复制           | 响应速度优先 | 单 CPU 环境下的 Client 模式                   |
| Serial Old        | 串行             | 老年代         | 标记-整理      | 响应速度优先 | 单 CPU 环境下的 Client 模式、CMS 的后备预案    |
| ParNew            | 并行             | 新生代         | 复制           | 响应速度优先 | 多 CPU 环境时在 Server 模式下与 CMS 配合        |
| Parallel Scavenge | 并行             | 新生代         | 复制           | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| Parallel Old      | 并行             | 老年代         | 标记-整理      | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| CMS               | 并发             | 老年代         | 标记-清除      | 响应速度优先 | 集中在互联网站或 B/S 系统服务端上的 Java 应用 |
| G1                | 并发             | 新生代、老年代 | 标记-整理+复制 | 响应速度优先 | 面向服务端应用，将来替换 CMS               |

注意：两个收集器间有连线，表明它们可以搭配使用

## Serial（新生代）

单线程收集器，它只会使用一个 CPU 或者线程去完成垃圾收集工作，而且在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束——这就是所谓的“Stop The World”，使用“复制”算法收集新生代垃圾

虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 JAVA 虚拟机运行在 Client 模式下默认的新生代垃圾收集器

![](JVM（5-垃圾收集器）/3.png)

## ParNew（新生代）

Serial 的多线程版本，即同时启动多个线程去进行垃圾收集，采用“复制”算法，但是也会暂停其他的工作，常见的应用场景是配合老年代的 CMS GC 工作，是很多 JAVA 虚拟机运行在 Server 模式下新生代的默认垃圾收集器

这个并行（Parallel）仅仅是描述同一时间多条 GC 线程协同工作，而不是 GC 线程和用户线程同时运行。ParNew 垃圾收集也是需要 Stop The World 的

![](JVM（5-垃圾收集器）/4.png)

## Parallel Scavenge（新生代）

Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量。

所谓吞吐量指的是运行用户代码的时间与处理器总消耗时间的比值。这个比例越高，证明垃圾收集占整个程序运行的比例越小。吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）

Parallel Scavenge 和 ParNew 的区别：

1. （自适应调节策略）虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量
2. 该收集器更关注吞吐量，尽快地完成计算任务，采用“复制”算法，多线程收集

![](JVM（5-垃圾收集器）/5.png)

Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量:

1. -XX：MaxGCPauseMillis，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发 GC。
2. -XX：GCTimeRatio，垃圾收集时间与总时间占比。这个是吞吐量的倒数，原理和 MaxGCPauseMillis 相同。

由于与吞吐量关系密切，Parallel Scavenge 收集器也经常被称作“吞吐量优先收集器”。

## Serial Old（老年代）

使用“标记—整理”算法， 单线程收集，主要是运行在 Client 默认的 Java 虚拟机默认的老年代收集器

![](JVM（5-垃圾收集器）/6.png)

## Parallel Old（老年代）

Parallel Scavenge 收集器的老年代版本，使用“标记—整理”算法， 多线程收集

![](JVM（5-垃圾收集器）/7.png)

## CMS（老年代）

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，适用于互联网站或者 B/S 系统的服务端，采用“标记—清除”算法，垃圾收集线程与用户线程（基本上）可以同时工作

**运行步骤**

1. 初始标记：单线程执行，标记 GC Roots 能直接关联到的对象，暂停所有的其他线程
2. 并发标记：对于初始标记过程所标记的初始化对象，进行并发追踪标记，此时其他线程可以继续工作，此处时间较长，但不停顿，并不能保证可以标记出所有的存活对象
3. 重新标记：修正并发标记期间因为用户程序继续运行而导致标记发生变动的那一部分对象的标记记录，在并发标记过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾，与用户线程不并发，且停顿时间比初始化标记较长，比并发标记短
4. 并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫

![](JVM（5-垃圾收集器）/8.png)

**标记阶段的执行过程**

remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记，目的是修正并发标记阶段中可能遗漏的对象引用变化。

在 remark 阶段，垃圾收集器会停止应用线程（STW），以确保在这个阶段不会有引用关系的进一步变化，这种暂停通常很短暂。remark 阶段主要包括以下操作：

1. 处理写屏障记录的引用变化：在并发标记阶段，应用程序可能会更新对象的引用（比如一个黑色对象新增了对一个白色对象的引用），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有可达对象都正确地标记为灰色或黑色。
2. 扫描灰色对象：再次遍历灰色对象，处理它们的所有引用，确保引用的对象正确标记为灰色或黑色。
3. 清理：确保所有引用关系正确处理后，灰色对象标记为黑色，白色对象保持不变。这一步完成后，所有存活对象都应当是黑色的。

**缺点**

1. 并发回收导致 CPU 资源紧张

在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS 默认启动的回收线程数：（CPU 核数+3）/4，当 CPU 核数不足 4 个时，CMS 对用户程序的影响就可能变得很大

2. 无法清理浮动垃圾

在 CMS 的并发清除阶段，用户线程还在继续运行，就还伴随着新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS 无法在当前收集中处理掉它们，只好留到下一次垃圾收集时再清理掉

3. 并发失败

由于在垃圾回收阶段用户线程还在并发运行，就还需要预留足够多的内存空间提供给用户线程使用，因此 CMS 不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。

要是 CMS 运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”，这时候虚拟机就不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了

4. 内存碎片问题

## G1（分代）

Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。

分代收集，收集范围包括新生代和老年代，采用“标记—整理+复制”算法，能独立管理整个 GC 堆（新生代和老年代），而不需要与其他收集器搭配

G1 把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理。

![](JVM（5-垃圾收集器）/1.png)

这样就避免了收集整个堆，而是按照若干个 Region 集进行收集，同时维护一个优先级列表，跟踪各个 Region 回收的价值，优先收集价值高的 Region。

**运行步骤**

1. 初始标记：标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。
2. 并发标记：和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象
3. 最终标记：STW，标记再并发标记过程中产生的垃圾。
4. 筛选回收：制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间，需要 STW

对每个 Region 的回收成本进行排序，按照用户自定义的回收时间来制定回收计划

![](JVM（5-垃圾收集器）/9.png)

相比 CMS，G1 的优点有很多，可以指定最大停顿时间、分 Region 的内存布局、按收益动态确定回收集。

只从内存的角度来看，与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个 Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。

| 特性           | CMS                               | G1                             |
| -------------- | --------------------------------- | ------------------------------ |
| 设计目标       | 低停顿时间                        | 可预测的停顿时间               |
| 并发性         | 是                                | 是                             |
| 内存碎片       | 是，容易产生碎片                  | 否，通过区域划分和压缩减少碎片 |
| 收集代数       | 年轻代和老年代                    | 整个堆，但区分年轻代和老年代   |
| 并发阶段       | 并发标记、并发清理                | 并发标记、并发清理、并发回收   |
| 停顿时间预测   | 较难预测                          | 可配置停顿时间目标             |
| 容易出现的问题 | 内存碎片、Concurrent Mode Failure | 较少出现长时间停顿             |

## 三色标记算法

![](JVM（5-垃圾收集器）/10.png)

三色标记法用于标记对象的存活状态，它将对象分为三类：

1. 白色：尚未访问的对象。垃圾回收结束后，仍然为白色的对象会被认为是不可达的对象，可以回收
2. 灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完，灰色对象是需要进一步处理的（GC 需要从此对象中去寻找垃圾）
3. 黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了，黑色对象是完全处理过的，不需要再处理（程序所需要的对象）

### 算法流程

从 GC Root 开始沿着他们的对象向下查找，用黑灰白的规则，标记出所有跟 GC Root 相连接的对象，扫描一遍结束后，一般需要进行一次短暂的 STW（Stop The World），再次进行扫描，此时因为黑色对象的属性都已经被标记过了，所以只需找出灰色对象并顺着继续往下标记（且因为大部分的标记工作已经在第一次并发的时候发生了，所以灰色对象数据会很少，标记时间也会短很多），此时程序继续执行，GC 线程扫描所有的内存，找出扫描之后依旧被标记为白色的对象（垃圾）清除

1. 初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰色。
2. 并发标记（Concurrent Marking）：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。

此阶段的一个问题是，应用线程可能在并发标记期间修改对象的引用关系，导致一些对象的标记状态不准确。

3. 重新标记（Remarking）：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。
4. 使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。

### 存在问题

1. 浮动垃圾：并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描，所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从 GC Root 中去找到，所以成为了浮动垃圾
2. 对象漏标问题：并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用），因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被 GC 回收

### 解决漏标方法

1. CMS：CMS 使用了增量更新的方法，当未被标记的对象被重新引用后，引用它的对象如果是黑色的话，那么将颜色置为灰色，在二次标记的时候让 GC 线程继续标记它的属性对象
2. G1：采用了 SATB 的方法，在标记开始的时候生成一个快照图标记存活对象，在一个引用断开后，要将此引用推到 GC 的堆栈中，保证对象还能被 GC 线程扫描到（通过在 write barrier 里把所有旧的引用所指向的对象都变成非白的），配合 Rset，去扫描哪些 Region 引用到当前的白色对象，若没有引用到当前对象，则回收

## ZCC

在 JDK 11 当中，加入了实验性质的 ZGC。它的回收耗时平均不到 2 毫秒，它是一款低停顿高并发的收集器。

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进：ZGC 在标记、转移和重定位阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 目标的最关键原因。

![](JVM（5-垃圾收集器）/11.png)
