---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 出现背景

Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失。持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失，当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的

## RDB

### 什么是 RDB？

RDB（Redis Database）：Redis 默认采用的持久化方式，它以快照的形式将进程数据持久化到硬盘中，恢复时将快照文件直接读到内存里。RDB 会创建一个经过压缩的二进制文件，文件以“.rdb”结尾（默认为 dump.rdb，也可以在 redis.conf 文件中修改），内存存储了各个数据库的键值对等信息。

优缺点：

1. 优点：RDB 生成紧凑压缩的二进制文件，体积小，使用该文件恢复数据的速度非常快，RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

2. 缺点：

* BGSAVE 每次运行都要执行 fork 操作创建子进程，属于重量级操作，不宜频繁执行，在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端；所以 RDB 持久化没办法做到实时的持久化
* 因为 RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。

### 触发方式

1. 手动触发：通过 SAVE 或 BGSAVE 命令触发 RDB 持久化操作，创建“.rdb”文件
2. 自动触发：通过配置 redis.conf 文件中的 save 配置，让服务器在满足指定条件时自动执行 BGSAVE 条件

```tex
# 将数据库保存到磁盘上：
#   save <秒数> <更改数>
#   如果满足给定的秒数和对数据库的写操作次数，则保存数据库。
#   在下面的示例中，行为将是：
#   当至少有1个键发生更改时，每900秒（15分钟）保存一次
#   当至少有10个键发生更改时，每300秒（5分钟）保存一次
#   当至少有10000个键发生更改时，每60秒保存一次
#   注意：您可以通过注释掉所有的 "save" 行来完全禁用保存功能。
#   也可以通过添加一个只有一个空字符串参数的保存指令来删除所有先前配置的保存点，如下面的示例：
#   save ""
save 900 1   #在900秒（15分钟）之内，对数据库进行了至少1次修改，则执行一次BGSAVE
save 300 10  #在300秒（5分钟）之内，对数据库进行了至少10次修改，则执行一次BGSAVE
save 60 10000 #在60秒之内，对数据库进行了至少10000次修改，则执行一次BGSAVE
```

**数据恢复**

当 Redis 服务启动时，用户可以通过指定配置文件或者传入启动参数的方式设置 save 选项，如果没有主动设置，服务器就会使用 redis.conf 文件中默认的条件

### BGSAVE

SAVE 命令执行期间，Redis 服务器将阻塞，直到“.rdb”文件创建完毕为止。而 BGSAVE 命令是异步版本的 SAVE 命令，它会使用 Redis 服务器进程的子进程，创建“.rdb”文件，BGSAVE 命令在创建子进程时会存在短暂的阻塞，之后服务器便可以继续处理其他客户端的请求。BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及 RDB 的操作都采用 BGSAVE 的方式，而 SAVE 命令已经废弃

**BGSAVE 命令的执行流程**

![](Redis（2-持久化）/1.png)

**BGSAVE 命令的原理**

在生成 RDB 期间，Redis 可以同时处理写请求，Redis 使用操作系统的多进程写时复制技术 COW（Copy On Write）来实现快照持久化，保证数据一致性

![](Redis（2-持久化）/2.png)

写时复制的缺点：

1. BGSAVE 快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改过的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 BGSAVE 快照。所以 Redis 在使用 BGSAVE 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时父进程和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据
2. 如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据
3. 在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的物理内存就会被复制一份，那么极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍

###  RDB 内存快照

在 Redis 执行写指令过程中，内存数据会一直变化。内存快照，指的就是 Redis 内存中的数据在某一刻的状态数据，在做数据恢复时，直接将 RDB 文件读入内存完成恢复

![](Redis（2-持久化）/3.png)

```java
save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```

## AOF

### 什么是 AOF？

AOF（Append Only File）：Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式进行数据恢复。类似于 Mysql 的 binlog，将存储在内存中的数据以文件的形式存储在磁盘上，解决了数据持久化的实时性，是目前 Redis 持久化的主流方式。

它的目的是为了解决生成 RDB 文件后数据不能实时一致的问题，所以它采用日志的形式来记录每个写操作，并追加到文件中，Redis 重启会根据日志文件的内容将写命令从前到后执行一遍来恢复数据

优缺点：

1. 优点：

* 与 RDB 持久化可能丢失大量的数据相比，AOF 持久化的安全性要高很多。通过使用 everysec 选项，用户可以将数据丢失的时间窗口限制在 1 秒之内
* Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作

2. 缺点：

* AOF 文件存储的是协议文本，它的体积要比二进制格式的“.rdb”文件大很多。AOF 需要通过执行 AOF 文件中的命令来恢复数据库，其恢复速度比 RDB 慢很多。
* AOF 在进行重写时也需要创建子进程，在数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞

### 命令追加、文件写入

1. 命令追加

服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。aof 缓冲区是 redisServer 结构体维护的一个 SDS 结构的属性。

2. 文件写入

将 aof 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache（操作系统），等待内核将数据写入硬盘；具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。

![](Redis（2-持久化）/4.png)

**为什么先执行命令，再把数据写入日志？**

避免额外的检查开销：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错

AOF 默认不开启，需要修改配置项来启用它：

```java
appendonly yes                          # 启用AOF
appendfilename "appendonly.aof"      	# 设置文件名
```

AOF 以文本协议格式写入命令，如：*3\r\n $3\r\nset\r\n$ 5\r\nhello\r\n$5\r\nworld\r\n

文本协议格式具有如下的优点：

1. 文本协议具有很好的兼容性
2. 直接采用文本协议格式，可以避免二次处理的开销
3. 文本协议具有可读性，方便直接修改和处理

### 文件同步机制

AOF 持久化的文件同步机制：为了提高程序的写入性能，现代操作系统会把针对硬盘的多次写操作优化为一次写操作

1. 当程序调用 write 对文件写入时，系统不会直接把数据写入硬盘，而是先将数据写入内存的缓冲区中
2. 当达到特定的时间周期或缓冲区写满时，系统才会执行 flush 操作，将缓冲区中的数据冲洗至硬盘中

这种优化机制虽然提高了性能，但也给程序的写入操作带来了不确定性

1. 对于 AOF 这样的持久化功能来说，冲洗机制将直接影响 AOF 持久化的安全性
2. 为了消除上述机制的不确定性，Redis 向用户提供了 appendfsync 选项，来控制系统冲洗 AOF 的频率
3. Linux 的 glibc 提供了 fsync 函数，可以将指定文件强制从缓冲区刷到硬盘

appendfsync 选项的取值和含义如下：

![](Redis（2-持久化）/5.png)

### 重写机制

因为 AOF 是通过保存被执行的写命令来持久化的，所以随着 Redis 的长时间运行，AOF 的体积会越来越大，那么这就会带来以下几个问题：

1. Linux 文件系统对单文件的大小有限制，AOF 文件过大的话无法保存。
2. 文件过大，持久化追加写命令的时候效率也会很低。
3. 数据载入（恢复）就更不用说了，它本身就是一条一条执行的，那就会导致执行的时间更久。

所以 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启动 AOF 重写机制来压缩 AOF 文件

```tex
127.0.0.1:6379> rpush list "A"   //["A"]
(integer) 1
127.0.0.1:6379> rpush list "B" "C" //["A","B","C"]
(integer) 3
127.0.0.1:6379> rpush list "D" "E" //["A","B","C","D","E"]
(integer) 5
127.0.0.1:6379> lpop list //["B","C","D","E"]
"A"
127.0.0.1:6379> lpop list //["C","D","E"]
"B"
```

光是记录这个 list 键的数据就要在 AOF 文件中追加六条命令。如果在实际项目中，AOF 中单单一个 key 键的持久化可能就得被追加成百上千次

尽管执行了这么多命令，而最终想要的数据就是当前 Redis 数据库存的值，所以重写的时候只用再读一遍数据库，把对应的写命令重写到 AOF 文件中，那保存的内容岂不是大大减少了

**实现流程**

AOF 重写机制是在重写时读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。在使用重写机制后，就会读取 name 最新的 value，然后用一条 set 命令记录到新的 AOF 文件，之前的第一个命令就没有必要记录了，因为它属于历史命令，没有作用了，一个键值对在重写日志中只用一条命令就行了

Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的，这样有两个好处：

1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
2. 子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生写时复制，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全

![](Redis（2-持久化）/6.png)

**触发方式**

1. 手动触发

手动执行 BGREWRITEAOF 命令，开始重写 aof 文件：

```tex
127.0.0.1:6379> BGREWRITEAOF
Background append only file rewriting started
```

2. 自动触发

可以在 redis.conf 文件中修改对应的配置，让服务器自动执行 BGREWRITEAOF 命令。

```tex
# 自动重写只追加文件。
# 当 AOF 日志文件的大小增长到指定的百分比时，Redis 可以通过隐式调用 BGREWRITEAOF 来自动重写日志文件。
# 工作原理如下：Redis 在最新的重写之后记住 AOF 文件的大小（如果自重启以来没有发生重写，则使用启动时的 AOF 大小）。
# 将此基准大小与当前大小进行比较。如果当前大小大于指定的百分比，则会触发重写。此外，您需要指定重写 # AOF 文件的最小大小，这对于避免即使达到增加百分比，但仍非常小的情况下重写 AOF 文件非常有用。
# 指定百分之零的百分比以禁用自动 AOF 重写功能。
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb #表示触发AOF重写的最小文件体积,大于或等于64MB自动触发。
```

## RDB 和 AOF 的区别

1. 数据可靠性

* RDB：可能会丢失最后一次快照之后的数据。如果 RDB 持久化过程中服务器宕机了，那么就会丢失这一次的数据。

* AOF：可能会丢失最后一次（或一秒）写操作的数据。如果 Redis 刚刚执行完一个写命令，还没来得及写 AOF 文件就宕机了，那么就会丢失这一条数据【当然也得看它配置的策略，如果配置的是 always（同步），那就丢一条，配置的 everysec（每秒）那就会丢 1 秒的数据】，但它也比 RDB 更加靠谱一些。

2. 性能：

* RDB：备份和数据恢复比较快，适合做数据恢复。RDB 存的是原生数据，所以直接加载到内存中即可。

* AOF：写性能较高【RDB 是对整个物理中的数据的快照，AOF 则仅仅是记录每次写命令】，但数据恢复速度相对较慢【AOF 需要对命令从头到尾再执行一次】。

3. 存储空间：

* RDB：二进制文件，体积较小。

* AOF：文本文件，体积较大。

4. 使用场景：

* RDB：适用于需要定期备份、大规模数据恢复、恢复速度要求比较快的场景。
* AOF：适用于对数据完整性要求较高、数据存档的场景。

**它俩同时开启会怎样？**

Redis 4.0 之前，如果两种方式同时开启，dump.rdb 和 appendonly.aof 文件都会生成，但在恢复数据时，会优先用 appendonly.aof 来恢复（比较完整），但 AOF 恢复数据相对较慢，如果 Redis 实例比较大的情况下，启动要花费很长时间。

## RDB-AOF 混合持久化

Redis 从 4.0 开始引入 RDB-AOF 混合持久化模式，这种模式是基于 AOF 持久化构建而来的（数据尽可能少丢失又能兼顾性能）。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启 AOF 混合持久化。Redis 服务器在执行 AOF 重写操作时，会按照如下原则处理数据：

1. 像执行 BGSAVE 命令一样，根据数据库当前的状态生成响应的 RDB 数据，并将其写入 AOF 文件中
2. 对于重写之后执行的 Redis 命令，则以协议文本的方式追加到 AOF 文件的末尾，即 RDB 数据之后

在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式追加到文件的末尾。

```tex
# 当重写 AOF 文件时，Redis能够在 AOF 文件中使用 RDB 前导以实现更快的重写和恢复。当开启此选项时，
# 重写后的 AOF 文件由两个不同的部分组成：
# [RDB 文件][AOF 尾部]
# 当加载 Redis 时，它会识别 AOF 文件以"REDIS"字符串开头，并加载带有前缀的 RDB 文件，然后继续加载 # AOF 的尾部。
aof-use-rdb-preamble yes
```

通过使用 RDB-AOF 混合持久化，用户可以同时获得 RDB 持久化和 AOF 持久化的优点，服务器既可以通过 AOF 文件包含的 RDB 数据来实现快速的数据恢复操作，又可以通过 AOF 文件来将丢失数据的时间窗口限制在 1s 之内