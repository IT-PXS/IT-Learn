---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 常用数据结构

1. String：简单的 key-value 结构，value 可以是字符串或数字，常用于计数：微博数、粉丝数
2. Hash：一个 string 类型的 field 和 value 的映射表，hash 适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值，可以用于存储用户信息、商品信息等
3. List：双向链表，可以用于实现微博的关注列表、粉丝列表、消息列表
4. Set：自动排重，可以实现共同关注、共同粉丝、共同喜好等
5. ZSet：zset 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，可以用于排行榜

Redis 后续版本又支持四种数据类型，它们的应用场景如下：

1. BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
2. HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
3. GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
4. Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。

## String

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串），但是如果一个 String 类型的 value 的值是数字，那么 Redis 内部会把它转成 long 类型来存储，从而减少内存的使用。

SDS 和 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，理由如下：

1. SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf [] 数组里的数据，所以 SDS 不仅能存放文本数据，而且能保存图片、音频、视频、压缩文件等二进制数据
2. SDS 获取字符串长度的时间复杂度为 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)，而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)
3. SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题

![](D:\blog\hexo\source\_posts\心得\Redis\Redis（6-数据类型）\24-1748177371846-1.png)

字符串对象的内部编码有 3 种 ：`int`、`raw` 和 `embstr`。Redis 会根据当前值的类型和长度来决定使用哪种编码来实现。

1. 如果一个字符串对象保存的是整数值，并且这个整数值可以用 `long` 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 `ptr` 属性里面（将 `void*` 转换成 `long` )，并将字符串对象的编码设置为 `int`。

![](D:\blog\hexo\source\_posts\心得\Redis\Redis（6-数据类型）\25-1748177371847-2.png)

2. 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 `raw`。

![](D:\blog\hexo\source\_posts\心得\Redis\Redis（6-数据类型）\26-1748177371847-3.png)

3. 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 `embstr`

![](D:\blog\hexo\source\_posts\心得\Redis\Redis（6-数据类型）\27-1748177371847-4.png)



注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：

- redis 2.+ 是 32 字节
- redis 3.0-4.0 是 39 字节
- redis 5.0 是 44 字节

`embstr` 编码是专门用于保存短字符串的一种优化编码方式，我们可以看到 `embstr` 和 `raw` 编码都会使用 `SDS` 来保存值，但不同之处在于 `embstr` 会通过一次内存分配函数来分配一块连续的内存空间来保存 `redisObject` 和 `SDS`。而 `raw` 编码会通过调用两次内存分配函数来分别分配两块空间来保存 `redisObject` 和 `SDS`。Redis 这样做会有很多好处。

- `embstr` 编码将创建字符串对象所需的内存分配次数从 `raw` 编码的两次降低为一次
- 释放 `embstr` 编码的字符串对象同样只需要调用一次内存释放函数
- 因为 `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。

embstr 缺点：如果字符串的长度增加需要重新分配内存时，整个 `redisObject` 和 `sds` 都需要重新分配空间，所以 `embstr` 编码的字符串对象实际上是只读的，redis 没有为 `embstr` 编码的字符串对象编写任何相应的修改程序。当我们对 `embstr` 编码的字符串对象执行任何修改命令（例如 append）时，程序会先将对象的编码从 `embstr` 转换成 `raw`，然后再执行修改命令。

## List

List 类型的底层数据结构是由 压缩列表或双向链表 实现的，一个列表最多可以存储 2^32-1 个元素

在 Redis3.2 版本以前列表类型的内部编码有两种

1. 压缩列表：如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），同时列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），
2. 双向链表：如果列表的元素不满足上面的条件

在 Redis3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表

## Hash

Hash 类型的底层数据结构是由 压缩列表或哈希表 实现的

1. 压缩列表：如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构，使用更加紧凑的结构实现多个元素的连续存储
2. 哈希表：如果哈希类型元素不满足上面条件

在 Redis7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了

## Set

Set 类型的底层数据结构是由 整数集合或哈希表 实现的，一个集合最多可以存储 `2^32-1` 个元素。

1. 整数集合：如果集合中的元素都是整数且元素个数小于 512（默认值：set-maxintset-entries 配置）
2. 哈希表：如果集合中的元素不满足上面条件

## ZSet

ZSet 类型的底层数据结构是由 压缩列表或跳表 实现的

1. 压缩列表：如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时
2. 跳跃表：如果有序集合的元素不满足上面的条件

在 Redis7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了

## BitMap

Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。

String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。