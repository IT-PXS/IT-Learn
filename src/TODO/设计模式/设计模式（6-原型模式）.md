---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

产生背景：单例模式可以避免重复创建消耗资源的对象，但是却不得不共用对象。若是对象本身也不让随意访问修改时，怎么办？通常做法是备份到副本，其他对象操作副本，最后获取权限合并

#### 浅克隆

1. 新建对象设置属性

```java
public interface IPrototype {
    IPrototype clone();
}
```

```java
@Data
public class PrototypeImplA implements IPrototype{
    private String name;

    private int age;

    private List<String> phoneList;

    @Override
    public IPrototype clone() {
        PrototypeImplA prototypeImplA = new PrototypeImplA();
        prototypeImplA.setAge(this.age);
        prototypeImplA.setName(this.name);
        prototypeImplA.setPhoneList(this.phoneList);
        return prototypeImplA;
    }
}
```

```java
public class ProtoTypeTest {
    public static void main(String[] args) throws Exception {
        PrototypeImplA prototypeImplA = new PrototypeImplA();
        prototypeImplA.setAge(18);
        prototypeImplA.setName("张三");
        List<String> phoneList = new ArrayList<>();
        phoneList.add("88888888");
        phoneList.add("77777777");
        prototypeImplA.setPhoneList(phoneList);

        PrototypeImplA cloneProtoType = (PrototypeImplA) prototypeImplA.clone();
        System.out.println(prototypeImplA.getPhoneList() == cloneProtoType.getPhoneList());//true
    }
}

// 结果：true
```

对象中如果有引用对象那么被克隆后的对象依然会指向原对象，如果需要复制两个独立的对象，则需要使用深克隆

2. 使用clone方法

```java
@Data
public class PrototypeB implements Cloneable {
    private String name;

    private int age;

    private List<String> phoneList;

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

```java
public class ProtoTypeTest2 {
    public static void main(String[] args) throws CloneNotSupportedException {
        PrototypeB prototypeImplB = new PrototypeB();
        prototypeImplB.setAge(18);
        prototypeImplB.setName("张三");
        List<String> phoneList = new ArrayList<>();
        phoneList.add("88888888");
        phoneList.add("77777777");
        prototypeImplB.setPhoneList(phoneList);

        PrototypeB cloneProtoTypeB = (PrototypeB)prototypeImplB.clone();
        System.out.println(prototypeImplB.getPhoneList() == cloneProtoTypeB.getPhoneList());//true
    }
}

// 结果：true
```

#### 深克隆

```java
@Data
public class PrototypeB implements Cloneable, Serializable {
    private String name;

    private int age;

    private List<String> phoneList;

    public Object clone() throws CloneNotSupportedException {
        return this.deepClone();
    }

    public PrototypeB deepClone(){
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);

            PrototypeB clone = (PrototypeB)ois.readObject();
            return clone;
        }catch (Exception e){
            return null;
        }
    }
}
```

