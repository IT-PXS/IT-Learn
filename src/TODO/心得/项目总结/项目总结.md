---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 秒杀

```txt
用户
 │
▼（验证码+令牌校验）
【获取动态秒杀路径】
 │
▼
【秒杀请求提交（带 path）】
 │
▼
【网关限流 + 验签 + 滑动窗口限流】
 │
▼
【Redis Lua：原子扣库存 + 用户去重】
 │
┌────────────────────────┐
│          Success       │
└────────────────────────┘
 │
▼
【发送秒杀消息 → MQ】
 │
▼
【消费者异步下单（幂等+落库+乐观锁）】
 │
▼
【写订单状态至 Redis】
 │
▼
【前端轮询结果接口 → 返回状态】
```

| 模块     | 技术                           | 说明                         |
| :------- | :----------------------------- | :--------------------------- |
| 前端     | 动态 URL + 验证码              | 防止提前刷单、路径暴露       |
| 网关     | Sentinel / Nginx               | QPS 限流、滑动窗口、黑名单    |
| 库存预扣 | Redis + Lua 脚本               | 原子性扣减库存、防重入       |
| 削峰处理 | Kafka / RocketMQ               | 消息异步处理，提升系统稳定性 |
| 订单落库 | MySQL + 乐观锁 + 唯一索引      | 精准扣减库存、防止重复下单   |
| 状态查询 | Redis                          | 前端轮询异步结果             |
| 安全防护 | 布隆过滤器 / 滑动窗口 / 验证码 | 全面防刷                     |

1. 动态路径防刷（秒杀前置接口）

```java
// 获取动态path接口
String path = MD5(userId + skuId + salt);
redis.setex("seckill:path:" + userId + ":" + skuId, 60, path);
```

**问题：秒杀页面中如果商品秒杀链接要是提前暴露出去可能有人直接访问 url 就提前秒杀了**

解决：做个时间校验不就可以解决了吗？没到秒杀时间不给秒杀。这种方案也存在问题，既然我知道了秒杀请求链接，那我通过程序不断获取最新的北京时间，可以达到 **毫秒级别** 的，我就在 00 毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送 N 次请求，搞不好你卖 100 个产品我全拿了。

**那这种情况怎么避免？**

简单，把 **URL 动态化**，就连写代码的人都不知道，你就通过 MD5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。　　

**怎么实现逻辑？**

在进行秒杀之前，先请求一个服务端地址，/getmiaoshaPath 这个地址，用来获取秒杀地址，传参为 商品 id，在服务端生成随机数（MD5）作为 pathId 存入缓存，（缓存过期时间 60s），然后将这个随机数返回给前端.

获得该 pathid, 后 前端在用这个 pathid 拼接在 Url 上作为参数，去请求 domiaosha 服务

后端接收到这个 pathid 参数，并且与 缓存中的 pathid 比较。

如果通过比较，进行秒杀逻辑，如果不通过，抛出业务异常，非法请求。

```js
/*点击秒杀之后 就访问后端 获取一个秒杀地址pathId*/
function getMiaoshaPath() {
    $.ajax({
        url :"/miaosha/getPath",
        type : "GET",
        data:{
            goodsId :$("#goodsId").val(),
            verifyCode : $("#verifyCode").val()
        },
        success:function(data){
            if (data.code ==0) {//
                var path = data.data
                domiaosha(path)
            }else {
                layer.msg(data.message)
            }
        },
        error :function () {
            layer.msg("客户端错误")
        }
    })
 
}
 
function domiaosha(path){
    $.ajax({
        url :"/miaosha/"+path+"/do_miaosha",//安全优化，带着这个path去访问
        type : "POST",
        data:{
            goodsId :$("#goodsId").val()
        },
        success:function(data){
            if (data.code ==0) {//成功 就跳转 订单页面 并传入 orderid
                // window.location.href= "/order_detail.htm?orderId="+data.data.id;
                //若果返回成功,即表示收到请求，等待中
                getMiaoshaResult($("#goodsId").val());
            }else {
                layer.msg(data.message)
            }
        },
        error :function () {
            layer.msg("客户端错误")
        }
    })
}
```

2. Redis 库存扣减 + 用户去重

```java
-- Redis Lua 脚本
if stock <= 0 then return -1 end
if user in success_set then return -2 end
DECR(stock)
SADD(success_user_set, userId)
return 1
```

3. 消息入队削峰（MQ）

- Producer：发送秒杀消息（userId + skuId）
- Consumer：落库（幂等校验 + 乐观锁更新）

4. 订单写库

```java
UPDATE goods SET stock = stock - 1
WHERE id = ? AND stock > 0;
-- 插入订单时加唯一索引 (userId + skuId)
```

5. 状态查询接口（前端轮询）

```java
// Redis 返回值: -1=失败, 0=排队中, 1=成功+订单ID
String result = redis.get("seckill:result:" + userId + ":" + skuId);
```

**你们系统怎么防止超卖？（重点）**

三层机制防止超卖：

* Redis Lua 脚本原子扣减库存，保证并发下不会多扣；
* 数据库乐观锁防止并发写入冲突；
* 消息队列异步下单，有效削峰解耦，最终落地只会写成功的单。

**不用缓存+数据库双写会不会导致数据不一致？**

不用双写是为了避免一致性控制困难。在我们系统中采用 Redis 单写库存，消息队列异步落库 + 乐观锁二次确认库存，整个链路保证最终一致，且失败可重试。

**Redis 扣库存后 MQ 落库失败，用户怎么办？**

我们不会立即告知用户“成功”，而是提示“排队中”，后台处理完成后将订单状态写入 Redis，用户通过轮询接口获取是否成功，避免了前端“假成功”。

**如何防止重复秒杀/重复下单？**

Redis Set 去重（秒杀前置），数据库订单表加唯一索引(userId+skuId)控制幂等，再加 MQ 消费端幂等处理，三重保障防止重复下单。

**如何防止机器刷单？**

多层防刷策略：

* 获取秒杀 path 接口必须滑动验证码；
* Path 一人一值，限时有效；
* 接口限流 + 布隆过滤器阻断非法访问；
* IP + UA 双重限制；网关层做黑名单防火墙。

## 运营指标

| 编号     | 全称                        | 通俗解释                             | 常见用途              | 面试答法示例                                               |
| :------- | :-------------------------- | :----------------------------------- | :-------------------- | :--------------------------------------------------------- |
| QPS      | Queries Per Second          | 每秒处理的请求数量（接口调用量）     | 衡量系统吞吐能力      | 系统接口 QPS 峰值 3000，设置 Sentinel QPS 限流阈值保护系统 |
| TPS      | Transactions Per Second     | 每秒事务处理数（数据库业务成功交易） | 衡量系统业务处理能力  | 数据库 TPS 峰值 800，需确保连接池写入能力不成为瓶颈        |
| RT       | Response Time               | 响应时间、单位：毫秒 ms              | 衡量接口快慢/用户体验 | 核心接口 P99 响应时间控制在 200ms 内                       |
| DAU      | Daily Active Users          | 每天活跃用户数                       | 衡量用户活跃度        | 系统 DAU 10万，接口需求受高并发流量，QPS 峰值 1500         |
| MAU      | Monthly Active Users        | 每月活跃用户数                       | 用户粘性评估          | 新功能上线后 MAU 提升了 30%                                |
| PV       | Page Views                  | 页面浏览数（访问量）                 | 常用于前端页面统计    | 某活动页 PV 超过 50w，需要 CDN 缓存防止刷流量              |
| UV       | Unique Visitors             | 独立访客数（按用户ID/IP 统计）       | 粗略衡量用户规模      | 活动日 UV 峰值 20w，配合限流防护服务稳定性                 |
| P99      | Percentile 99               | 表示 99% 的请求响应时间低于该值      | 衡量响应性能          | 接口 P99 为 180ms，说明极端慢请求较少                      |
| RPS      | Requests Per Second (~QPS)  | 每秒请求数（更偏向 HTTP 层）         | Web 服务器负载能力    | Nginx 入口 RPS 峰值 5000，需做负载均衡                     |
| 容量指标 | 系统能处理的最大并发/请求数 | 系统承压能力                         | 压测评估              | 单节点支持 2000 QPS，集群部署 5 台，总容量 1w QPS          |