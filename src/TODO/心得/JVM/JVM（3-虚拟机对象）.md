---
title: JVM（3-虚拟机对象）
series: JVM
tags:
  - JVM
categories: Java
cover: /img/index/
top_img: /img/index/
published: false
abbrlink: 48844
date: 2024-12-09 22:38:34
description: 
---

## 对象创建过程

单纯从语言层面，新建一个对象，可以通过 new、反射、复制、反序列化等等。接下来，我们探究以下在虚拟机中，对象的创建是一个什么样的过程。

我们以虚拟机遇到一个 new 指令开始：

1. 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用
2. 检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程
3. 类加载检查通过后，接下来虚拟机将为新生对象分配内存。

内存分配有两种方式：指针碰撞（Bump The Pointer）、空闲列表（Free List）

- 指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”

- 空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录


两种方式的选择由 Java 堆是否规整决定，Java 堆规整由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定

4. 内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。
5. 接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。

![](JVM（3-虚拟机对象）/1.png)

分配内存线程安全问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。

线程安全问题有两种可选方案：

1. 对分配内存空间的动作进行同步处理——实际上虚拟机是采用 CAS 配上失败重试的方式保证更新操作的原子性
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

从虚拟机角度来看，设置完对象头信息以后初始化就已经完成了，但是对于 Java 程序而言，new 指令之后会接着执行 \< init > ()方法，对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

## 对象的内存布局

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

![](JVM（3-虚拟机对象）/2.png)

HotSpot 虚拟机对象的对象头部分包括两类信息。

第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为“Mark Word”。

考虑到虚拟机的空间效率，Mark Word 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。

例如在 64 位的 HotSpot 虚拟机中，如对象未被同步锁锁定的状态下，Mark Word 的 64 个比特存储空间中的 31 个比特用于存储对象哈希码，4 个比特用于存储对象分代年龄，2 个比特用于存储锁标志位，在其他状态（轻量级锁、重量级锁、偏向锁）下对象的存储内容变化如图示。

![](JVM（3-虚拟机对象）/3.png)

对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据信息并不一定要经过对象本身，如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

**为什么非要进行 8 字节对齐呢？**

这是因为 CPU 进行内存访问时，一次寻址的指针大小是 8 字节，正好是 L1 缓存行的大小。如果不进行内存对齐，则可能出现跨缓存行访问，导致额外的缓存行加载，降低了 CPU 的访问效率。

## 对象的访问定位

### 通过句柄访问

Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

![](JVM（3-虚拟机对象）/4.png)

### 使用直接指针访问

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象的地址

![](JVM（3-虚拟机对象）/5.png)

**句柄与指针比较**

1. 使用句柄的最大好处是引用中存储的是稳定的句柄地址，在对象移动（GC）时只改变实例数据指针地址，引用自身不需要修改。

2. 直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。

如果是对象频繁 GC 使用句柄方法好；如果是对象频繁访问则直接指针访问好

### Java 对象大小的计算

在 Java 中，一个空 Object 对象的大小是 8byte，这个大小只是保存堆中一个没有任何属性的对象的大小

```java
Object ob = new Object(); 
// 它所占的空间为：4byte+8byte
```

4byte 是上面所说的 Java 栈中保存引用的所需要的空间，而那 8byte 则是 Java 堆中对象的信息。因为所有的 Java 非基本类型的对象都需要默认继承 Object 对象，因此不论什么样的 Java 对象，其大小都必须是大于 8byte

```java
Class MaNong { 
    int count;
    boolean flag;
    Object obj; 
}
空对象大小（8byte）+int大小（4byte）+Boolean大小（1byte）+空Object引用的大小（4byte）=17byte
因为Java在对对象内存分配时都是以8的整数倍来分，因此大于17byte的最接近8
的整数倍的是24，因此此对象的大小为24byte
```

基本类型的包装类型已经成为对象了，因此需要把它们作为对象来看待，包装类型的大小至少是 12byte（声明一个空 Object 至少需要的空间），而且 12byte 没有包含任何有效信息，同时，因为 Java 对象大小是 8 的整数倍，因此一个基本类型包装类的大小至少是 16byte。可能的话应尽量少使用包装类

## 内存泄漏

在 Java 中，内存泄漏就是存在一些不会再被使用却没有被回收的对象，这些对象有两个特点：

1. 这些对象是可达的，即在有向图中，存在通路可以与其相连
2. 这些对象是无用的，即程序以后不会再使用这些对象

如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄露，这些对象不会被 GC 所回收，然而它却占用内存

### 内存泄漏的根本原因

长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收

### 内存泄漏的情况

1. 静态集合类引起的内存泄漏

静态集合类，如：HashMap、LinkedList 等，如果这些容器为静态的，那么它们的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前不能被释放，从而造成内存泄漏。（生命周期对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收）

```java
public class MemoryLeak {
    static List list = new ArrayList();
    // 该方法执行完后，obj 引用的对象发生内存泄漏
    public void oomTest() {
        Object obj = new Object(); // 局部变量
        list.add(obj);
    }
}
```

2. 当集合里面的对象属性被修改后，再调用 remove()方法时不起作用

当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中的哈希值就不同了，这就导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏

3. 监听器：释放对象的时候没有删除监听器

4. 各种连接：比如数据库连接、网络连接、IO 连接，除非其显式地调用了其 close()方法将其连接关闭，否则是不会自动被 GC 回收的

```java
try {
    Connection conn = null;
    Class.forName("com.mysql.jdbc.Driver");
    conn = DriverManager.getConnection("url", "", "");
    Statement stmt = conn.createStatement();
	ResultSet rs = stmt.executeQuery("....");
} catch (Exception e) { 

} finally {
	//不关闭连接
}
```

5. 内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放

内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象不会被垃圾回收，这也造成内存泄漏

```java
class Outer{
    private int[] data;
 
    public Outer(int size) {
        this.data = new int[size];
    }
 
    class Innner{
    }
 
    Innner createInner() {
        return new Innner();
    }
}
 
public class Demo {
    public static void main(String[] args) {
        List<Object> list = new ArrayList<>();
        int counter = 0;
        while (true) {
            list.add(new Outer(100000).createInner());
            System.out.println(counter++);
        }
    }
}
```

解决方法：将内部类改为 static，它所引用的对象或属性也必须是静态的，此时内部类不再持有外部对象的引用

6. 单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方法），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏

防止单例导致内存泄漏的实例：这样不管传入什么 Context 最终将使用 Application 的 Context

```java
// 使用了单例模式
public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context;
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
```

### 避免内存泄漏的方法

1. 尽量不要使用 static 成员变量，减少生命周期
2. 及时关闭资源
3. 不用的对象，可以手动设置为 null

### 危害

1. 频繁 GC：系统分配给每个应用的内存资源都是有限的，内存泄漏导致其他组件可用的内存减少后，一方面会使得 GC 的频率加剧，再发生 GC 的时候，所有进程都必须等待，GC 的频率越高，用户越容易感应到卡顿。另一方面内存变少，可能使得系统额外分配给该对象一些内存，而影响整个系统的运行情况
2. 导致程序运行崩溃：一旦内存不足以为某些对象分配所需要的空间，将会导致程序崩溃，造成用户体验差
