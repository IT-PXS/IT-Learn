---
title: JVM（6-类加载）
series: JVM
tags:
  - JVM
categories: Java
cover: /img/index/
top_img: /img/index/
published: false
abbrlink: 48844
date: 2024-12-09 22:38:34
description: 
---

## JVM 调优

### 内存参数

1. -Xms \< size >（初始堆大小，默认为物理内存的 1/64）
2. -Xmx \< size >（最大堆大小，默认为物理内存的 1/4）
4. -Xss \< size >（每个线程的堆栈大小）
5. -Xmn \< size >（年轻代大小，1.4 之后）
6. -XX: NewSize（设置年轻代大小，1.3 或 1.4）
7. -XX: MaxNewSize（年轻代最大值，1.3 或 1.4）
8. -XX: PermSize（设置持久代初始值，默认为物理内存的 1/64）
9. -XX: MaxPermSize（设置持久代最大值，默认为物理内存的 1/4）
10. -XX: NewRatio（年轻代【包括 Eden 和两个 Survivor 区】与老年代的比值【除去持久代】）
11. -XX: SurvivorRatio（Eden 区与 Survivor 区的大小比值）

**Jdk7 版本及以前的主要参数**

| **参数名称**    | **含义**       | **默认值** |
| --------------- | -------------- | ---------- |
| -XX: PermSize    | 设置持久代     |            |
| -XX: MaxPermSize | 设置最大持久代 |            |

**Jdk8 版本的重要特有参数**

| **参数名称**         | **含义**   | **默认值** |
| -------------------- | ---------- | ---------- |
| -XX: MetaspaceSize    | 元空间大小 |            |
| -XX: MaxMetaspaceSize | 最大元空间 |            |

### GC 信息参数

| **参数名称**                          | **含义**                                                 |                                                              |
| ------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| -XX:+PrintGC                          | 打印 GC 日志                                             | 输出形式: [GC 118250K-> 113543K(130112K), 0.0094143 secs] [Full GC 121376K-> 10414K(130112K), 0.0650971 secs] |
| -XX:+PrintGCDetails                   | 打印详细 GC 日志                                         | 输出形式: [GC [DefNew: 8614K-> 781K(9088K), 0.0123035 secs] 118250K-> 113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-> 8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K-> 10414K(130112K), 0.0436268 secs] |
| -XX:+PrintGCTimeStamps                | GC 时，打印进行启动到现在经历的时间                      |                                                              |
| -XX:+PrintGC: PrintGCTimeStamps        |                                                          | 可与-XX:+PrintGC -XX:+PrintGCDetails 混合使用 输出形式: 11.851: [GC 98328K-> 93620K(130112K), 0.0082960 secs] |
| -XX:+PrintGCApplicationStoppedTime    | 打印垃圾回收期间程序暂停的时间（STW），可与上面混合使用    | 输出形式: Total time for which application threads were stopped: 0.0468229 seconds |
| -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前程序未中断的执行时间，可与上面混合使用 | 输出形式: Application time: 0.5291524 seconds                 |
| -XX:+PrintHeapAtGC                    | 打印 GC 前后的详细堆栈信息                                 |                                                              |
| -Xloggc: filename                      | 把相关日志信息记录到文件以便分析，与上面几个配合使用     |                                                              |
| -XX:+PrintClassHistogram              | garbage collects before printing the histogram.          |                                                              |
| -XX:+PrintTLAB                        | 查看 TLAB 空间的使用情况                                   |                                                              |
| XX:+PrintTenuringDistribution         | 查看每次 minor GC 后新的存活周期的阈值                     | Desired survivor size 1048576 bytes, new threshold 7 (max 15) new threshold 7 即标识新的存活周期的阈值为 7。 |

## OOM 出现场景

### Java heap space（堆溢出）

1. 错误原因：
+ 代码中可能存在大对象分配
+ 可能存在内存泄漏，导致在多次 GC 之后，还是无法找到一块足够大的内存容纳当前对象
2. 解决方法：调高 head 的最大值，即-Xmx 的值调大
3. 注意：如果程序存在内存泄漏，一味地增加 heap 空间也只是推迟该错误出现的时间而已，所以要检查程序是否存在内存泄漏

### unable to create new native thread（方法栈溢出）

1. 错误原因：当 JVM 向 OS 请求创建一个新线程时，而 OS 却由于内存不足无法创建新的 native 线程（线程太多）
2. 解决方法：如果 JVM 内存调得过大或者可利用率小于 20%，可以建议将 heap 及 perm 的最大值下调，并将线程栈调小，即-Xss 调小，如：-Xss128k

### GC overhead limit exceeded（堆太小）

定义：超过 98%的时间用来做 GC 并且回收了不到 2%的堆内存时会抛出异常

1. 错误原因：此 OOM 是由于 JVM 在 GC 时，对象过多，导致内存溢出，建议调整 GC 的策略，在一定比例下开始 GC 而不要使用默认的策略，或者将新生代和老年代设置合适的大小，需要进行微调存活率
2. 解决方法：改变 GC 策略，在老年代 80%时就开始 GC，并且将-XX: SurvivorRation（-XX: SurvivorRation = 8）和-XX: NewRatio（-XX: NEWRatio = 4）设置得更合理

### Java perm space

1. 错误原因：此 OOM 是由于 JVM 中 perm 的最大值不满足需要
2. 解决方法：提高 heap 的最大值，即-XX: MaxPermSize 的值调大

### Requested array size exceeds VM limit（分配超大数组）

1. 错误原因：应用程序（或者被应用程序调用的 APIs）试图分配一个大于堆大小的数组。例如：如果应用程序 new 一个数组对象，大小为 512M，但是最大堆大小为 256M，数组的大小超过虚拟机的限制
2. 解决方法：
+ 检查 heap 的-Xmx 是不是设置地过小
+ 如果 heap 的-Xmx 已经足够大，那么请检查应用程序是不是存在 bug，例如：应用程序可能在计算数组的大小时，存在算法错误，导致数组的 size 很大，从而导致巨大的数组被分配

### Out of swap space（swap 溢出）

1. 错误原因：
+ 操作系统配置了较小的交换区
+ 系统的另外一个进程正在消耗所有的内存
2. 解决方法：
+ 检查 os 的 swap 是不是没有设置或者设置得过小
+ 检查是否有其他进程在消耗大量的内存，从而导致当前的 JVM 内存不够分配

## 逃逸分析

逃逸分析（Escape Analysis）是 Java 虚拟机（JVM）中的一种优化技术，用于分析对象在程序中的“逃逸”范围，即分析对象的引用是否超出了方法或线程的作用域。通过逃逸分析，JVM 可以了解对象的生命周期和作用域，从而进行优化，例如避免不必要的堆内存分配，甚至可以将对象分配到栈上，从而提升性能。

### 基本概念

1. 逃逸：指一个对象的引用是否超出了某个方法或线程的作用范围。如果一个对象的引用只在局部方法内有效，且没有被外部访问到，认为该对象是“没有逃逸”的。相反，如果对象的引用被传递到方法外部或者被其他线程访问，则认为该对象“逃逸”了。
2. 非逃逸对象：指对象的引用仅在方法或线程内部有效，其他地方无法访问该对象的实例。
3. 逃逸对象：指对象的引用被传递到方法外部或者在其他线程中使用，导致它的生命周期在当前线程或方法的范围之外。

### 逃逸分析的优化

逃逸分析的目的是通过分析对象的逃逸情况，优化内存分配和并发执行。

#### 堆栈分配

1. 堆分配：当对象需要在方法调用之间共享时，它们通常分配到堆上，并由垃圾回收器管理。
2. 栈分配：如果对象的引用在方法内部有效，且没有逃逸到方法外部，JVM 可以将该对象分配到栈上，方法调用结束后栈空间自动回收。这比堆分配效率更高，因为栈分配的对象没有垃圾回收的开销，且不会引起内存碎片问题。

通过逃逸分析，JVM 可以判断对象是否可以分配在栈上，从而避免堆内存的分配和垃圾回收的成本。

#### 同步消除

逃逸分析还可以消除不必要的同步锁。假设一个对象的引用没有逃逸到线程外部，那么多个线程在访问这个对象时，不必加锁，因为该对象不会在多个线程之间共享。通过逃逸分析，JVM 可以消除这些无效的同步锁，提升并发性能。

#### 分配提升

如果逃逸分析发现某个对象的引用只在某个特定方法或线程内部有效，那么它可以将对象的分配提升到方法开始时，这样多个对象的内存分配可以合并到一起，减少内存的分配次数。

### 应用场景

#### 堆和栈的优化

逃逸分析能够判断哪些对象是仅在方法内部使用的，JVM 可以将这些对象分配到栈上，而不是堆上，节省了堆内存分配和垃圾回收的开销。通常来说，栈分配比堆分配更高效，因为栈上的内存是局部的，方法结束时栈空间会被自动释放。

#### 同步优化

逃逸分析能够分析对象是否存在跨线程的共享。如果某个对象不会被其他线程访问（即没有逃逸），那么多线程访问该对象时不需要加锁。这种优化可以有效减少锁竞争，提升多线程程序的性能。

#### 分配提升（Allocation Elimination）

通过逃逸分析，JVM 可以判断某些对象的创建和销毁是多余的。如果这些对象的生命周期仅在某个方法中存在，而且不会逃逸到方法外部，那么 JVM 可以优化掉这些对象的创建，减少不必要的内存分配。

### 逃逸分析的例子

#### 非逃逸对象

```java
public class EscapeAnalysisTest {
    public void method1() {
        MyObject obj = new MyObject();
        obj.someMethod();
    }
}
```

在这个例子中，`obj` 是局部变量，且只在 `method1` 方法内部使用。如果 `obj` 的引用没有逃逸到方法外部，JVM 会认为 `obj` 是一个非逃逸对象。在这种情况下，JVM 可以将 `obj` 分配到栈上，而不需要在堆上分配内存。

#### 逃逸对象

```java
public class EscapeAnalysisTest {
    public MyObject method2() {
        MyObject obj = new MyObject();
        return obj;
    }
}
```

在这个例子中，`obj` 被返回并传递到方法外部。因此，`obj` 的引用会逃逸到方法外部，JVM 会认为 `obj` 是一个逃逸对象。在这种情况下，`obj` 必须分配到堆上，并由垃圾回收器管理。

### 实现和优化

逃逸分析是 JVM 中的一种静态分析技术，现代的 JDK 提供了一些优化选项来启用逃逸分析。具体实现取决于不同的 JVM 和 JIT 编译器（例如 HotSpot JVM）。

在 HotSpot JVM 中，逃逸分析的具体优化通常依赖于 **JIT 编译器**（即时编译器）进行处理。JIT 编译器通过编译期的静态分析，推测对象是否可能逃逸，如果对象不会逃逸，则可以采取相关优化。

#### 启用逃逸分析

可以通过设置 JVM 参数来启用逃逸分析。例如，在 JDK 9 及以后版本中，可以使用 `-XX:+DoEscapeAnalysis` 参数启用逃逸分析：

```bash
java -XX:+DoEscapeAnalysis -XX:+PrintEscapeAnalysis MyClass
```

这个参数会启用逃逸分析，并打印逃逸分析的结果。

### 局限性和挑战

虽然逃逸分析可以显著提高程序性能，但它并不是一种万能的优化技术。以下是一些局限性和挑战：

1. 动态分析的限制：逃逸分析是静态分析的结果，因此它无法完全准确地分析动态情况下的对象逃逸情况。例如，某些对象可能在运行时根据条件被传递到外部，这种情况静态分析无法准确判断。
2. 代码复杂性：逃逸分析对于复杂的程序，特别是多线程环境中的对象引用分析，可能会变得非常困难。
3. 线程交互：逃逸分析在分析多线程程序时，需要考虑线程间的通信和共享数据，这会使得优化变得更加复杂。

### 总结

逃逸分析是 Java 中一种重要的优化技术，能够帮助 JVM 判断对象的引用是否超出方法或线程的作用范围，从而进行性能优化。它能够帮助 JVM 做出以下优化决策：

1. 将非逃逸对象分配到栈上，而不是堆上，减少堆内存分配和垃圾回收的开销。
2. 优化多线程程序的同步，避免无效的锁操作。
3. 优化内存分配，减少不必要的对象创建。

虽然逃逸分析在提高性能方面非常有用，但它也面临一些挑战，特别是在动态或复杂的程序中。总体而言，逃逸分析是 JIT 编译器优化中的一项重要技术，适用于大多数简单和中等复杂度的程序。

## 性能监控

### JDK 工具

![](JVM/1.png)

### Linux 命令行工具

进行性能监控和问题排查的时候，常常是结合操作系统本身的命令行工具来进行。

| 命令    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| top     | 实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息 |
| vmstat  | 对操作系统的虚拟内存、进程、CPU 活动进行监控                  |
| pidstat | 监控指定进程的上下文切换                                     |
| iostat  | 监控磁盘 IO                                                   |

其它还有一些第三方的监控工具，同样是性能分析和故障排查的利器，如：MAT、GChisto、JProfiler、arthas。

## JVM 后台运行的线程

1. 虚拟机线程（JVMThread）：虚拟机线程在 JVM 到达安全点（SafePoint）时出现。
2. 周期性任务线程：通过定时器调度线程来实现周期性操作的执行。
3. GC 线程：GC 线程支持 JVM 中不同的垃圾回收活动。
4. 编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是 JVM 跨平台的具体实现。
5. 信号分发线程：接收发送到 JVM 的信号并调用 JVM 方法
