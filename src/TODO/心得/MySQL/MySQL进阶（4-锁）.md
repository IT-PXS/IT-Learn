---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 锁介绍

### 死锁

指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象

解决死锁的方法：

1. 如果不同程序并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率

### 使用方式分类

#### 乐观锁

乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据；如果别人修改了数据则放弃操作，否则执行操作

#### 悲观锁

悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据

### 锁粒度分类

#### 全局锁

作用：锁定整个数据库，使其处于只读状态。

使用场景：全库备份等需要确保数据一致性的场景。

```sql
FLUSH TABLES WITH READ LOCK;
// 在执行此命令后，所有写操作都会被阻塞，直到锁被释放
```

#### 表级锁

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低

1. 一般在执行 DDL 语句时会对整个表进行加锁，比如：ALTER TABLE 等操作
2. 如果对 InnoDB 的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话，那么将会锁整张表
3. 表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如：WEB 应用

**InnoDB 和 MyISAM 加锁**

1. InnoDB 在使用过程中只要不通过索引检索数据时，全部是表锁。
2. MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。

#### 行级锁

行级锁：开销大，加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率小，并发度最高

1. 最大程度的支持并发，同时也带来了最大的锁开销
2. 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的
3. 行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。行级锁更适合于有大量索引条件并发更新少量不同数据，同时又有并发查询的应用，如：一些在线事务处理（OLTP）系统

**InnoDB 和 MyISAM 加锁**

1. InnoDB 只有通过索引条件检索数据才使用行级锁。
2. MyISAM 引擎并不支持行级锁。

### 锁级别分类

#### X 锁和 S 锁

1. 排他锁（X 锁——写锁）

若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁，这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A

2. 共享锁（S 锁——读锁）

若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁，这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改

| 锁    | X    | S    |
| ----- | ---- | ---- |
| **X** | 互斥 | 互斥 |
| **S** | 互斥 | 兼容 |

## 行锁

注意：InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。

### 行锁使用

#### 查询

访问数据库的时候，锁定整个行数据，防止并发错误。如：InnoDB 存储引擎使用行锁

```plsql
update user set age = 10 where id = 49;
update user set age = 10 where name = 'Tom';
```

1. 第一条 SQL 使用主键查询，只需要在 id = 49 这个主键索引上加上锁。
2. 第二条 SQL 使用二级索引来查询，那么首先在 name = Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id = 49 这个主键索引上加锁。InnoDB 中的二级索引的叶节点存储的是主键值（或者说聚簇索引的值），所以通过二级索引查询数据时，还需要将对应的主键去聚簇索引中再次查询

![](MySQL进阶（4-锁）/1.png)

#### 更新

如果更新操作涉及多个行，例如：update user set age = 10 where id > 49; 执行过程如下图所示，MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止

![](MySQL进阶（4-锁）/2.png)

注意：使用主键索引需要加一把锁；使用二级索引需要在二级索引和主键索引上加一把锁

### 行锁类型

![](MySQL进阶（4-锁）/3.png)

|              | RECORD | GAP  | NEXT-KEY | II GAP |
| ------------ | ------ | ---- | -------- | ------ |
| **RECORD**   | 互斥   | 兼容 | 互斥     | 兼容   |
| **GAP**      | 兼容   | 兼容 | 兼容     | 兼容   |
| **NEXT-KEY** | 互斥   | 兼容 | 互斥     | 兼容   |
| **II GAP**   | 兼容   | 互斥 | 互斥     | 兼容   |

#### 记录锁（Record Lock）

只锁定对应的记录，记录锁是有 S 锁和 X 锁之分的

触发条件：必须是精准命中索引并且索引是唯一索引，比如：主键 id

#### 间隙锁（Gap Lock）

锁住记录和记录之间的间隙，对于键值在条件范围内但并不存在的记录，就叫做间隙，InnoDB 在此时也会对间隙加锁，间隙锁是所在两个存在的索引之间，是一个开区间，例如：15 和 18 之间，是有（16，17）这个间隙存在的

间隙锁作用：防止其他事务插入记录造成幻读

触发条件：当我们查询数据用范围查询而不是相等查询时，查询条件命中索引，即便是没有查到符合条件的记录，此时也会将查询条件中的范围进行锁定，即使是范围中不存在的数据也会被锁定

#### 临键锁（Next-Key Lock）

锁住所属记录之间的间隙，记录锁+间隙锁的机制叫做 Next-Key Lock，临键锁是个左开右闭的，比如：（16，18]

触发条件：查找过程中访问到的对象才会加锁

#### 插入意向锁（II GAP LOCK）

是一种间隙锁，在执行 INSERT 的插入操作设置，如果多个事务 INSERT 到同一个索引间隙之间，但没有在同一位置上插入，则不会产生任何的冲突。比如：有值为 4 和 7 的索引记录，现在有两事务分别尝试插入值为 5 和 6 的记录，在获得插入行的排他锁之前，都使用插入意向锁锁住 4 和 7 之间的间隙，但两者之间并不会相互阻塞，因为这两行并不冲突。插入意向锁只会和间隙或者 Next-Key 锁冲突，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

### 行锁加锁规则
1. 主键索引，等值查询记录存在时

执行 select * from t_lock_test where id = 5 for update;，通过 performance_schema.data_locks 表查看 MySQL 事务获取锁的情况，发现在主键索引上对 id = 5 的记录加上了记录锁

![](MySQL进阶（4-锁）/4.png)

![](MySQL进阶（4-锁）/5.png)

2. 主键索引，等值查询记录不存在

执行 select * from t_lock_test where id = 7 for update;

![](MySQL进阶（4-锁）/6.png)

![](MySQL进阶（4-锁）/7.png)

在主键索引对 id = 9 的记录加间隙锁（包含 7 的间隙为（5，9），加锁的单位为 next-key lock，所以对 id = 9 的记录加 next-key lock，因为查询条件不包含 9，所以退化为 gap 锁）

为什么 id = 9 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id = 9 这条记录，但是这次的案例是查询 id = 7 的记录，只要保证前后两次查询 id = 7 的结果集相同，就能避免幻读的问题了，所以即使 id = 9 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 7 加间隙锁，避免其他事务插入 id = 7 的新记录就行了。

3. 主键索引，范围查询记录存在
+ select * from t_lock_test where id > 4 and id < 8 for update;
+ select * from t_lock_test where id > 4 and id <= 8 for update;
+ select * from t_lock_test where id > 4 and id < 9 for update;

![](MySQL进阶（4-锁）/8.png)

![](MySQL进阶（4-锁）/9.png)

因为 id = 5 的记录存在于查询条件中（id > 4 and id <8、id> 4 and id <=8、id> 4 and id <9），所以先对id=5的记录加临键锁，除此之外还要对查询条件的其他部分（id> 5 and id < 9）加锁，即需要对 id = 9 的记录加锁，因为查询条件不包含 id = 9，所以退化为间隙锁

4. 主键索引，范围查询记录不存在

select * from t_lock_test where id > 5 and id < 9 for update;，给 id = 9 的索引加间隙锁

![](MySQL进阶（4-锁）/10.png)

select * from t_lock_test where (id > 6 and id <9) or id> 12 for update;，给 id = 9 的记录加间隙锁，给 supremum pseudo-record 加临键锁

![](MySQL进阶（4-锁）/11.png)

5. 唯一索引，等值查询记录存在

select * from t_lock_test where mobile ='18901970832' for update;，先在唯一索引 idx_mobile 上给 mobile ='<font style="color:rgb(77, 77, 77);"> 18901970832 </font>'的记录，再在主键索引上对对应的 id = 9 的记录加记录锁。当修改数据的条件是非主键索引，最终也得查找主键索引（真正要修改的数据页都是主键索引的叶子节点），但是当修改数据的条件是主键索引，是不需要去查找其他索引的

![](MySQL进阶（4-锁）/12.png)

![](MySQL进阶（4-锁）/13.png)

6. 唯一索引，等值查询记录不存在

select * from t_lock_test where mobile ='15933661689' for update; 会在查询条件所在的间隙的下一条记录加间隙锁

![](MySQL进阶（4-锁）/14.png)

![](MySQL进阶（4-锁）/15.png)

这种情况没在主键索引加锁，因为在这里加间隙锁的目的就是为了禁止其他事务插入 mobile ='17118168721'的记录

7. 唯一索引，范围查询记录存在

select * from t_lock_test where mobile >'13931766909' and mobile <'17041965526' for update;

![](MySQL进阶（4-锁）/16.png)

![](MySQL进阶（4-锁）/17.png)

在 idx_mobile 索引上给 mobile ='15373838350'和 mobile ='17118168721'的记录加临键锁，并且因为 mobile ='15373838350'这条记录在查询范围内并且存在真实的记录，所以给这条记录对应主键索引的位置（id = 4 的记录）也加上了记录锁

为什么给 mobile ='17118168721'的记录也是加邻键锁而不是间隙锁呢（'17041965526'明明小于 '17118168721'呀）？这种情况只是在唯一索引上对查询条件所在区间的下一条记录加了临键锁，但是没在对应主键索引上加记录锁

![](MySQL进阶（4-锁）/18.png)

其他事务 6683 执行 select * from t_lock_test where mobile ='17118168721' for update; 会被阻塞，在 idx_mobile 唯一索引上获取 mobile ='17118168721’的记录锁的状态为 WAITING，但另一个事务 6690 事务执行 select * from t_lock_test where id = 2 for update; 不会被阻塞，在主键索引上获取 id = 2 的记录锁的状态为 GRANTED

![](MySQL进阶（4-锁）/19.png)

8. 唯一索引，范围查询记录不存在

select * from t_lock_test where mobile >'13931766909' and mobile <'15101965526' for update;

![](MySQL进阶（4-锁）/20.png)

![](MySQL进阶（4-锁）/21.png)

对 mobile ='15373838350’的记录加邻键锁，正常来说查询条件不包含 mobile ='15373838350’这条记录，应该退化成间隙锁的

9. 非唯一索引，等值查询记录存在

select * from t_lock_test where name ='Bob' for update;

![](MySQL进阶（4-锁）/22.png)

![](MySQL进阶（4-锁）/23.png)

在非唯一索引 idx_name 上，对 name ='Bob'的两条记录都加了临键锁，对 name ='Bob'记录后面 name ='Kara'的那条记录加了间隙锁，目的是为了防止在 Anna-9 至 Bob-2、Bob-2 至 Bob-4、Bob-4 至 Kara-5 这三个间隙中插入 name ='Bob'的记录，在主键索引上，对对应的 id = 2、id = 4 的记录加记录锁

10. 非唯一索引，等值查询记录不存在

select * from t_lock_test where name ='Danny' for update;

![](MySQL进阶（4-锁）/24.png)

![](MySQL进阶（4-锁）/25.png)

对查询条件所在间隙的下一条记录加间隙锁，目的是为了禁止其他事务在 Bob-4 至 Kara-5 之间插入 name ='Danny'的记录

11. 非唯一索引，范围查询记录存在

select * from t_lock_test where name > 'Anna' and name < 'Danny' for update;

![](MySQL进阶（4-锁）/26.png)

![](MySQL进阶（4-锁）/27.png)

12. 非唯一索引，范围查询记录不存在

select * from t_lock_test where name > 'Danny' and name < 'Ella' for update;

![](MySQL进阶（4-锁）/28.png)

![](MySQL进阶（4-锁）/29.png)

**总结**

1. 查询条件为主键索引时，如果查询条件是等值查询且记录存在，只对符合条件的记录加记录锁
2. 查询条件为主键索引时，如果查询条件是等值查询且记录不存在，会对查询所在间隙的下一条记录加间隙锁（相当于锁的范围就是查询条件所在间隙）
3. 查询条件为主键索引时，如果查询条件是范围查询且记录存在，会对符合条件的记录加临键锁，对剩余未加锁的间隙的下一条记录加间隙锁（相当于锁的范围就是查询条件对应的区间）
4. 查询条件为主键索引时，如果查询条件是范围查询且记录不存在，会对查询条件所在范围的下一条记录加间隙锁（相当于锁的范围还是查询条件对应的区间）
5. 查询条件为唯一索引时，如果查询条件是等值查询且记录存在，除了会在唯一索引上对查到的记录加记录锁，也会在主键索引上对那些记录的主键对应位置上加记录锁
6. 查询条件为唯一索引时，如果查询条件是等值查询且记录不存在，在唯一索引上，只会在查询条件所在间隙的下一条记录加间隙锁，在主键索引上不加锁
7. 查询条件为唯一索引时，如果查询条件是范围查询且记录存在，在唯一索引上，会对查询到的记录加临键锁，对剩余未加锁的间隙的下一条记录加临键锁（不会退化成间隙锁），在主键索引上，会对在查询范围内的记录在主键索引上对应的位置加记录锁
8. 查询条件是唯一索引时，如果查询条件是范围查询且记录不存在，在唯一索引上，会对查询条件所在间隙的下一条记录加临键锁，在主键索引上不加锁
9. 查询条件是非唯一索引时，如果查询条件是等值查询且记录存在，在非唯一索引上，会对符合查询条件的记录加临键锁，对剩余未加锁的间隙的下一条记录加间隙锁，在主键索引上，对符合查询条件的记录在主键索引对应的位置上加记录锁
10. 查询条件是非唯一索引时，如果查询条件是等值查询且记录不存在时，会对符合查询条件所在间隙的下一条记录加间隙锁，在主键索引上不加锁
11. 查询条件是非唯一索引时，如果查询条件是范围查询且记录存在，会对符合查询条件的记录加临键锁，对剩余未加锁的间隙的下一条记录加临键锁（实际上加间隙锁就可以了），在主键索引上，对符合查询条件的记录在主键索引对应的位置上加记录锁
12. 查询条件是非唯一索引时，如果查询条件是范围查询且记录不存在，会对查询条件所在间隙的下一条记录加临键锁，主键索引不加锁

## 表锁

### 表锁使用

访问数据库的时候，锁定整个表数据，防止并发错误。

注意：

1. MyISAM 存储引擎使用表锁；
2. InnoDB 既支持行锁，也支持表锁，当查询列没有索引时，InnoDB 就不会去搞行锁了，所以搞表锁把整张表给锁住了

表锁使用的是一次性锁技术，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。除了使用 unlock tables 显式释放锁之外，会话持有其他表锁时执行 lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁

![](MySQL进阶（4-锁）/30.png)

### 读锁和写锁
```sql
-- 表级别的共享锁，也就是读锁；
lock tables t_student read;

-- 表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。也就是说如果本线程对表加了「共享表锁」，那么本线程接下来如果要对表执行写操作的语句，是会被阻塞的，当然其他线程对表进行写操作时也会被阻塞，直到锁被释放。

要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：

```sql
unlock tables;
```

另外，当会话退出后，也会释放所有表锁。

### 元数据锁（MDL）
我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

1. 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
2. 对一张表做结构变更操作的时候，加的是 MDL 写锁；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

当有线程在执行 select 语句（加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（释放 MDL 读锁）。

反之，当有线程对表结构进行变更（加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL 写锁）。

**MDL 不需要显示调用，那它是在什么时候释放的?**

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。

那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

1. 线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

**为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？**

这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

### 意向锁

表锁和行锁虽然锁定范围不同，但是会相互冲突，当你要加表锁时，势必要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL 引入了意向锁，来检查表锁和行锁的冲。当事务要在记录上加上行锁时，要首先在表上加上意向锁，这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率，意向锁的目的是为了快速判断表里是否有记录被加锁。

1. 意向共享锁（IS）

事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁或 IX 锁

2. 意向排他锁（IX）

事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

|        | X    | IX   | S    | IS   |
| ------ | ---- | ---- | ---- | ---- |
| **X**  | 互斥 | 互斥 | 互斥 | 互斥 |
| **IX** | 互斥 | 兼容 | 互斥 | 兼容 |
| **S**  | 互斥 | 互斥 | 兼容 | 兼容 |
| **IS** | 互斥 | 兼容 | 兼容 | 兼容 |

### AUTO-INC 锁
表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。

AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。

InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

1. 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
2. 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
3. 当 innodb_autoinc_lock_mode = 1：
+ 普通 insert 语句，自增锁在申请之后就马上释放；
+ 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题

![](MySQL进阶（4-锁）/31.png)

session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后两个 session 同时执行向表 t2 中插入数据。

如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：

1. session B 先插入了两个记录，(1,1,1)、(2,2,2)；
2. 然后，session A 来申请自增 id 得到 id = 3，插入了（3,5,5)；
3. 之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。

可以看到，session B 的 insert 语句，生成的 id 不连续。

当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format = statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。

但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。

要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。

所以，当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题

## MyISAM 表锁

### 处理锁方式

1. 表共享读锁：不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求
2. 表独占写锁：一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞

默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先响应写锁等待队列中的锁请求，然后再是读锁中等待的获取锁的请求，这种设定也是 MyISAM 表不适合于有大量更新操作和查询操作的原因。大量更新操作可能会造成查询操作很难以获取读锁，从而过长的阻塞。同时一些需要长时间运行的查询操作，也会使得线程“饿死”，应用中尽量避免出现长时间运行的查询操作（可以通过使用中间表等措施对 SQL 语句做一定的“分解”，使每一步查询都能在较短的时间内完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）

### 对表加锁分析
MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁的原因

MyISAM 存储引擎支持并发插入，以减少给定表的读操作和写操作之间的争用：如果 MyISAM 表在数据文件中没有空闲块（由于删除或更新导致的空行），则行始终插入数据文件的末尾，在这种情况下，可以自由混合并发使用 MyISAM 表的 INSERT 和 SELECT 语句而不需要加锁（你可以在其他线程进行读操作的情况下，同时将行插入到 MyISAM 表中）。如果文件中有空闲块，则并发插入会被禁止，但当所有的空闲块重新填充新数据时，它又会自动启用，要控制此行为，可以使用 MySQL 的 concurrent_insert 系统变量

1. 当 concurrent_insert = 0 时，不允许并发插入功能
2. 当 concurrent_insert = 1 时，允许对没有空闲块的表使用并发插入，新数据位于数据文件结尾（缺省）
3. 当 concurrent_insert = 2 时，不管表有没有空闲块，都允许在数据文件结尾并发插入

### 显式加表锁
一般表锁都是隐式加锁的，不需要我们去主动声明，但是也有需要显式加锁的情况

例如：有一个订单表 orders，其中记录有订单的总金额 total，同时还有一个订单明细表 order_detail，假设我们需要检查这两个表的金额合计是否相等

```plsql
SELECT SUM(total) FROM orders;
SELECT SUM(subtotal) FROM order_detail;
```

如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail 表可能已经发生了改变

```plsql
LOCK tables orders read local,order_detail read local;
SELECT SUM(total) FROM orders;
SELECT SUM(subtotal) FROM order_detail;
Unlock tables;
```

## InnoDB 行锁和表锁
### 加锁方法
1. 意向锁是 InnoDB 自动加的，不需要用户干预
2. 对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及的数据集加上排他锁
3. 对于普通的 SELECT 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集添加共享锁或排他锁：
+ 共享锁（S）：select * from table_name where ... lock in share mode。将查找的数据加上一个 share 锁，表示其他的事务只能对这些数据进行简单的 select 操作，而不能进行 DML 操作，可以对该记录加共享锁，但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁
+ 排他锁（X）：select * from table_name where ... for update。将对应的索引访问条目加上排他锁，其他事务可以查询记录，但是不能对该记录加共享锁或排他锁，相当于一个 update 语句，只能等待锁释放后再加锁

