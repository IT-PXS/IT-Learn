---
title: MySQL（3-事务和日志）
tags: MySQL
categories: 数据库
cover: /img/index/mysql.png
top_img: /img/index/mysql.png
published: false
abbrlink: 63240
date: 2024-11-22 22:38:34
description:
---

## 七大原则

### 开闭原则

开闭原则（Open-Closed Principle，OCP）是指一个软件实体（如类、模块和函数）应当对扩展开放，对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展

举例：很多互联网公司都实行弹性作息时间，只规定每天工作 8 小时，但对于每天工作 8 小时这个规定是关闭的，但是你什么时候来、什么时候走是开放的。

**使用案例**

```java
// 矩形
public class Rectangle {
    public double getWidth() {
        return width;
    }
    
    public double getHeight() {
        return height;
    }
}

// 面积计算器
public class AreaCalculator {
    public double area(Rectangle shape){
        return shape.getWidth() * shape.getHeight();
    }
}
```

存在问题：这时候又多了一个圆形类，面积计算器得重新修改

```java
// 圆形
public class Circular {
    public double getRadius() {
        return radius;
    }
}

// 面积计算器
public class AreaCalculator {
    public double area(Object shape) {
        if(shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            return rectangle.getWidth() * rectangle.getHeight();
        } else if (shape instanceof Circular) {
            Circular circular = (Circular) shape;
            return circular.getRadius() * circular.getRadius() * Math.PI;
        } else {
            throw new RuntimeException("There is no such type.");
        }
    }
}
```

解决方法：

1. 把计算面积这个公有逻辑变成一个接口

```java
public interface Shape {
    public double getArea();
}

public class Rectangle implements Shape {
    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return getWidth() * getHeight();
    }   
}
```

2. 当需求变更，需要计算圆形面积的时候，我们只需创建一个圆形的类，并实现 shape 即可

```java
public class Circular implements Shape {
    public double getRadius(){
        return radius;
    }

    public double getArea() {
        return getRadius() * getRadius() * Math.PI;
    }
}
```

### 依赖倒置原则

1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象

其核心思想是：要面向接口编程，不要面向实现编程

1. 每个类尽量提供接口或抽象类，或者两者都具备
2. 变量的声明类型尽量是接口或者是抽象类
3. 任何类都不应该从具体类派生
4. 使用继承时尽量遵循里氏替换原则

**使用案例**

```java
class Customer {
    public void shopping(ShaoguanShop shop) {
        // 购物
        System.out.println(shop.sell());
    }
}
```

存在问题：

1. 顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。
2. 顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则

```java
// 如果该顾客想从另外一家商店购物，就需要修改代码
class Customer {
    public void shopping(WuyuanShop shop) {
        // 购物
        System.out.println(shop.sell());
    }
}
```

解决方法：定义商店的共同接口 shop，顾客类面向接口编程

```java
//商店
interface Shop {
    public String sell(); //卖
}

//韶关网店
class ShaoguanShop implements Shop {
    public String sell() {
        return "韶关土特产：香菇、木耳……"; 
    } 
}

//婺源网店
class WuyuanShop implements Shop {
    public String sell() {
        return "婺源土特产：绿茶、酒糟鱼……"; 
    }
} 
```

```java
//顾客
class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell()); 
    }
}
```

```java
public class DIPtest {
    public static void main(String[] args) {
        Customer wang = new Customer();
        System.out.println("顾客购买以下商品："); 
        wang.shopping(new ShaoguanShop()); 
        wang.shopping(new WuyuanShop());
    }
}
```

1. 构造器注入

```java
//顾客
class Customer {
    
    private Shop shop;
    
    public Customer(Shop shop) {
        this.shop = shop;
    }
    
    public void shopping() {
        //购物
        System.out.println(shop.sell()); 
    }
}
```

2. setter 注入

```java
//顾客
class Customer {
    
    private Shop shop;
    
    public void setShop(Shop shop) {
        this.shop = shop;
    }
    
    public void shopping() {
        //购物
        System.out.println(shop.sell()); 
    }
}
```

### 单一职责原则

规定一个类应该有且只有一个引起它变化的原因，否则类应该被拆分。假设有一个类负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能导致另一个职责的功能发生故障，这样一来，这个类就存在两个导致类变更的原因。该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费

**使用案例 1**

```java
public class Course {
 
    public void study(String courseName) {
        if("直播课".equals(courseName)) {
            System.out.println(courseName + "不能快进");
        } else {
            System.out.println(courseName + "可以反复回看");
        }
    }
    
    public static void main(String[] args) {
        Course course = new Course();
        course.study("直播课");
        course.study("录播课");
    }
}
```

从上面的代码来看，Course 类承担了两种处理逻辑。假如现在要对课程进行加密，直播课程和录播课程的加密逻辑不一样，必须修改代码，而修改代码的逻辑势必会相互影响，容易带来不可控的风险。我们对职责进行解耦，分别创建两个类：LiveCourse 和 ReplayCourse。

```java
public class LiveCourse {
 
    public void study(String courseName) {
        System.out.println(courseName + "不能快进看");
    }
}
```

```java
public class ReplayCourse {
 
    public void study(String courseName){
        System.out.println(courseName + "可以反复回");
    }
}
```

```java
public static void main(String[] args) {
    LiveCourse liveCourse = new LiveCourse();
    liveCourse.study("直播课");
 
    ReplayCourse replayCourse = new ReplayCourse();
    replayCourse.study("录播课");
}
```

**使用案例 2**

```java
public interface UserService { 
    
    public void login(String username, String password);
    
    public void register(String email, String username, String password);
    
    public void logError(String msg);
    
    public void sendEmail(String email);   
}
```

UserService 既要负责用户的注册和登录，还要负责日志的记录和邮件的发送，并且后者的行为明显区别于前者。假设我要修改发送邮件的逻辑就得修改这个类，这时候还得回归登录注册逻辑，明显不合理

```java
// 只负责登录注册
public interface UserService {
    
    public void login(String username, String password);
    
    public void register(String email, String username, String password);
}

// 只负责日志
public interface LogService {
    public void logError(String msg);
}

// 只负责发送邮件
public interface EmailService {
    public void sendEmail(String email);
}
```

**使用案例 3**

对于方法，不要把不相关的对象实例作为参数传进来，如果发现某个方法依赖某个不相关的对象，那么这个方法的实现就可能存在问题

```java
public void loadImage(String url, ImageView view) {
	// 下载图片，展示图片
}
```

对于 loadImage 这个方法，参数 url 是 ok 的，但是参数 ImageView 却是不合理的，因为这里做了两个操作，下载图片，展示图片，应该将这个方法再进行拆分

```java
// 下载图片 
public void loadImage(String url) {

}

// 显示图片
public void displayImage(String url, ImageView view) {
	// 调用 getBitmap (url)  获取图片
	// 获取图片后将其设置到 view 中。
}

// 根据 url 获取图片， 
public void getBitmap(String url) {

}
```

### 接口隔离原则

类间的依赖关系应该建立在最小的接口上，建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用

1. 接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑
2. 为依赖接口的类定制服务，只提供调用者需要的方法，屏蔽不需要的方法
3. 提高内聚，减少对外交互，使接口用最少的方法去完成最多的事情

**使用案例**

```java
public interface IAnimal {
    
    void run();
    
    void swim();
    
    void fly();
}
```

```java
public class Dog implements IAnimal {
    
    @Override
    public void run() {
        System.out.println("我跑的很快");
    }

    @Override
    public void swim() {
        System.out.println("我还会游泳");
    }

    @Override
    public void fly() {

    }
}
```

存在问题：Dog 没有对应的 fly 方法

解决方法：将方法细化，拆分为多个类

```java
public interface IFlyAnimal {
    void fly();
}
```

```java
public interface IRunAnimal {
    void run();
}
```

```java
public interface ISwimAnimal {
    void swim();
}
```

```java
public class Dog implements IRunAnimal,ISwimAnimal {
    @Override
    public void run() {
        System.out.println("我跑的很快");
    }

    @Override
    public void swim() {
        System.out.println("我还会游用");
    }
}
```

### 迪米特法则

指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle，LKP），尽量降低类与类之间的耦合度。

迪米特原则主要强调：只与你的直接朋友交谈，不跟“陌生人”说话，“朋友”指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用

1. 在类的划分上，应该创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标
2. 在类的结构设计上，尽量降低类成员的访问权限
3. 在类的设计上，优先考虑将一个类设置成不变类
4. 在对其他类的引用上，将引用其他对象的次数降到最低
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）
6. 谨慎使用序列化（Serializable）功能

**使用案例 1**

```java
//明星
class Star {
    private String name;
    
    Star(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}

//粉丝
class Fans {
    
    private String name;
    
    Fans(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}

//媒体公司
class Company {
    private String name;
    
    Company(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```

```java
//经纪人
class Agent {
    
    private Star myStar;
    
    private Fans myFans;
    
    private Company myCompany;
    
    public void setStar(Star myStar) {
        this.myStar = myStar;
    }
    
    public void setFans(Fans myFans) {
        this.myFans = myFans;
    }
    
    public void setCompany(Company myCompany) {
        this.myCompany = myCompany;
    }
    
    public void meeting() {
        System.out.println(myFans.getName()+"与明星"+myStar.getName()+"见面了。");
    }
    
    public void business() {
        System.out.println(myCompany.getName()+"与明星"+myStar.getName()+"洽淡业务。");
    }
}
```

```java
public class LoDtest {
    
    public static void main(String[] args) {
        Agent agent = new Agent();
        agent.setStar(new Star("林心如"));
        agent.setFans(new Fans("粉丝韩丞"));
        agent.setCompany(new Company("中国传媒有限公司"));
        agent.meeting();
        agent.business();
    }
}
```

**使用案例 2**

```java
public class Course {
 
}
```

```java
public class TeamLeader {
 
    public void checkNumberOfCourses(List<Course> courseList){
        System.out.println("目前已发布的课程数量是："+courseList.size());
    }
}
```

```java
public class Boss {
 
    public void commandCheckNumber(TeamLeader teamLeader) {
    	//模拟Boss一页一页往下翻页，TeamLeader实时统计
        List<Course> courseList = new ArrayList<Course>();
        for (int i= 0; i < 20 ;i ++) {
            courseList.add(new Course());
        }
        teamLeader.checkNumberOfCourses(courseList);
    }
}
```

```java
public static void main(String[] args) {
    Boss boss = new Boss();
    TeamLeader teamLeader = new TeamLeader();
    boss.commandCheckNumber(teamLeader);
}
```

根据迪米特原则，Boss 只想要结果，不需要跟 Course 直接交流。

```java
public class TeamLeader {
 
    public void checkNumberOfCourses() {
        List<Course> courseList = new ArrayList<Course>();
        for(int i = 0 ;i < 20;i++) {
            courseList.add(new Course());
        }
        System.out.println("目前已发布的课程数量是："+courseList.size());
    }
}
```

```java
public class Boss {
 
    public void commandCheckNumber(TeamLeader teamLeader) {
        teamLeader.checkNumberOfCourses();
    }
}
```

### 里氏替换原则

子类可以扩展父类的功能，但不能改变父类原有的功能，指如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 O2，使得以 T1 定义的所有程序 P 在所有的对象 O1 都替换成 O2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。

1. 子类中可以增加自己特有的方法
2. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类更宽松
4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类的方法更严格或相等

**使用案例**

```java
public class Bird {
    
    public void fly() {
        System.out.println("我正在天上飞");
    }
}
```

```java
public class Eagle extends Bird {
    
    @Override
    public void fly() {
        System.out.println("我正在8000米高空飞翔");
    }
}
```

```java
public class TestLsp {
    
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly();
        //替换成子类Eagle，子类重写了父类Bird的fly方法
        Eagle eagle = new Eagle();
        eagle.fly();
    }
}
```

### 合成复用原则

指的是在软件复用时，要尽量先使用组合（has-a）或者聚合（contains-a）等关联关系而不是继承关系来实现，这样可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少

**使用案例**

```java
public class DBConnection {
 
    public String getConnection() {
        return "MySQL数据库连接";
    }
}
```

```java
public class ProductDao{
 
    private DBConnection dbConnection;
    
    public void setDbConnection(DBConnection dbConnection) {
        this.dbConnection = dbConnection;
    }
 
    public void addProduct() {
        String conn = dbConnection.getConnection();
        System.out.println("使用"+conn+"增加产品");
    }
}
```

## 设计模式分类

### 创建型模式（Creational Patterns）

目的：处理对象的创建机制，通过控制对象的创建方式，提高代码的灵活性和可复用性。

常见模式：

1. 简单工厂模式（Simple Factory）：包含一个静态或实例方法，根据输入参数返回对应的具体产品。
2. 工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定实例化哪个类。
3. 抽象工厂模式（Abstract Factory）：创建相关或依赖对象的家族，而无需指定具体类。
4. 建造者模式（Builder）：分步骤构建复杂对象，分离构造过程和表示。
5. 单例模式（Singleton）：确保一个类只有一个实例，并提供全局访问点。
6. 原型模式（Prototype）：通过复制现有对象来创建新对象，而非通过 `new`。

适用场景：需要解耦对象创建逻辑、优化资源使用（如共享对象）或灵活扩展对象类型时。

### 结构型模式（Structural Patterns）

目的：通过组合类或对象形成更大的结构，解决对象之间的协作问题。

常见模式：

1. 适配器模式（Adapter）：使不兼容的接口能够协同工作。
2. 装饰器模式（Decorator）：动态地为对象添加新功能，避免继承导致的类爆炸。
3. 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问（如延迟加载、权限控制）。
4. 组合模式（Composite）：将对象组合成树形结构以表示“部分-整体”层次结构。
5. 外观模式（Facade）：为复杂子系统提供一个简化接口。
6. 桥接模式（Bridge）：将抽象与实现分离，使它们可以独立变化。
7. 享元模式（Flyweight）：通过共享技术高效地支持大量细粒度对象。

适用场景：需要简化系统接口、处理对象间兼容性、或优化对象结构时。

###  行为型模式（Behavioral Patterns）

目的：关注对象之间的职责分配和算法抽象，解决对象间的交互问题。

常见模式：

1. 观察者模式（Observer）：定义对象间的一对多依赖，当一个对象状态改变时，所有依赖者自动通知。
2. 策略模式（Strategy）：定义一系列算法，封装每个算法并使它们可互换。
3. 命令模式（Command）：将请求封装为对象，支持请求的排队、日志或撤销操作。
4. 模板方法模式（Template Method）：定义算法的骨架，将某些步骤延迟到子类实现。
5. 责任链模式（Chain of Responsibility）：将请求的发送者和接收者解耦，使多个对象都有机会处理请求。
6. 状态模式（State）：允许对象在其内部状态改变时改变行为。
7. 迭代器模式（Iterator）：提供一种方法顺序访问聚合对象的元素，而不暴露其内部表示。
8. 中介者模式（Mediator）：通过一个中介对象封装一系列对象交互，减少耦合。
9. 备忘录模式（Memento）：捕获并外部化对象的内部状态，以便后续恢复。
10. 访问者模式（Visitor）：将算法与对象结构分离，便于新增操作而不修改类。
11. 解释器模式（Interpreter）：定义一种特定领域语言的语法规则，并提供一个解释器来解析和执行该语言中的表达式。

适用场景：需要解耦对象间的交互、动态选择行为算法或管理复杂状态流转时。
