---
title: JVM（1-基本介绍）
series: JVM
tags:
  - JVM
categories: Java
cover: /img/index/
top_img: /img/index/
published: false
abbrlink: 48844
date: 2024-12-09 22:38:34
description: 
---

## 出现背景

因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java 内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果

## 什么是 JMM？

JMM（Java Memory Model，Java 内存模型）是一种 抽象的规范，定义了多线程环境下的可见性、原子性和有序性，用于解决共享变量的可见性问题 和 指令重排导致的线程安全问题。

<img src="JUC（4-JMM内存模型）/2.png" style="zoom:67%;" />

**JMM 主要解决哪些问题？**

1. 可见性：一个线程对共享变量的修改，其他线程是否能立即看见？
2. 原子性：多个线程对共享变量进行操作时，是否能保证不可分割？
3. 有序性：Java 代码的执行顺序是否和编写顺序一致？

**JMM 如何保证可见性？**

JMM 通过 volatile 关键字、synchronized、Lock 机制保证可见性。

1. volatile 变量的修改对所有线程立即可见（通过内存屏障 + 禁止缓存实现）。
2. synchronized 确保变量的修改在进入和退出同步块时刷新到主内存。
3. Lock（如 ReentrantLock） 也通过内存屏障保障可见性。

**volatile 能保证原子性吗？**

不能，volatile 只能保证可见性和禁止指令重排，但无法保证原子性。

```java
private static volatile int count = 0;

public static void increment() {
    count++;  // 不是原子操作，包含 读取-修改-写入
}
```

多个线程同时执行 increment()，可能会发生丢失更新问题。解决方案：

1. 使用 synchronized
2. 使用 AtomicInteger

## 内存划分

JMM 规定了内存主要划分为 主内存和工作内存 两种，此处的主内存和工作内存跟 JVM 内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是 Java 堆中的对象实例部分，工作内存对应的是栈中的部分区域。从更底层的来说，主内存对应的是硬件的物理内存 ，工作内存对应的是寄存器和高速缓存

![](JUC（4-JMM内存模型）/1.png)

JMM 在设计时候考虑到，如果 Java 线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。

出现问题：当一个线程修改了自己工作内存中的变量，对其他线程是不可见的，会导致线程不安全的问题，因为 JMM 指定了一套标准来保证开发者在编程多线程程序的时候，能够控制什么时候内存会被同步给其他线程

**为什么线程要用自己的内存？**

1. 在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。
2. 现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。

## 内存交互操作

内存交互操作有 8 种，虚拟机实现必须保证每一个操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上运行例外）

1. lock（锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
2. unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后续的 load 动作使用
4. load（载入）：作用于工作内存的变量，它把 read 操作从主存中取出的变量放入工作内存中
5. use（使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
6. assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
7. store（存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用
8. write（写入）：作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中

规则：

1. 不允许 read 和 load、store 和 write 操作之一单独出现，即使用了 read 必须 load，使用了 store 必须 write
2. 不允许线程丢失它最近的 assign 操作，即工作变量的数据改变了之后，必须告知主存
3. 不允许一个线程将没有 assign 的数据从工作内存同步回主内存
4. 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量，即对变量实施 use、store 操作之前，必须经过 load 和 assign 操作
5. 一个变量同一时间只有一个线程能对其进行 lock，多次 lock 后，必须执行相同次数的 unlock 才能解锁
6. 如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值
7. 如果一个变量没有被 lock，就不能对其进行 unlock 操作，也不能 unlock 一个被其他线程锁住的变量
8. 对一个变量进行 unlock 操作之前，必须把此变量同步回主内存

## 模型特征

1. 原子性

例如上面八项操作，在操作系统里面是不可分割的单元，被 synchronized 关键字或其他锁包裹起来的操作也可以认为是原子的。从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作

```java
synchronized (this) {
    a=1;
    b=2;
}
```

例如一个线程观察另外一个线程执行上面的代码，只能看到 a、b 都被赋值成功的结果，或者 a、b 都尚未被赋值的结果

2. 可见性

每个工作线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。volatile 关键字要求被修改之后的变量立即更新到主内存，每次使用前从主内存处进行读取，因此 volatile 可以保证可见性。除了 volatile 以外，synchronized 和 final 也能实现可见性，synchronized 保证 unlock 之前必须先把变量刷新回主内存，final 修饰的字段在构造器中一旦完成初始化，并且构造器没有 this 逸出，那么其他线程就能看到 final 字段的值

3. 有序性

Java 的有序性跟线程有关。如果在线程内部观察，会发现当前线程的一切操作都是有序的；如果在线程外部观察，会发现线程的所有操作都是无序的，因为 JMM 的工作内存和主内存之间存在延迟，而且 Java 会对一些指令进行重新排序，volatile 和 synchronized 可以保证程序的有序性

## Final 域的内存语义

被 final 修饰的变量，相比普通变量，内存语义有一些不同

1. JMM 禁止把 final 域的写重排序到构造器的外部
2. 在一个线程中，初次读该对象和读该对象下的 final 域，JMM 禁止处理器重新排序这两个操作

```java
public class FinalConstructor {
    final int a;
    int b;
    static FinalConstructor finalConstructor;

    public FinalConstructor() {
        a = 1;
        b = 2;
    }

    public static void write() {
        finalConstructor = new FinalConstructor();
    }

    public static void read() {
        FinalConstructor constructor = finalConstructor;
        int A = constructor.a;
        int B = constructor.b;
    }
}
```

假设现在有线程 A 执行 FinalConstructor.write()方法，线程 B 执行 FinalConstructor.read()方法

1. 对于 Final 的第一条规则，因为 JMM 禁止把 final 域的写重排序到构造器的外部，而对普通变量没有限制，所以变量 A = 1，而变量 B 可能会等于 2（构造完成），也有可能等于 0（第 11 行代码被重排序到构造器的外部）
2. 对于 Final 的第二条规则，如果 constructor 的引用不为 null，A 必然为 1，要么 constructor 为 null，抛出空指针异常，保证读 final 域之前，一定会先读该对象的引用，但是普通对象就没有这种规则

## happens-before 规则

先行发生规则：当 A 操作先行发生于 B 操作，则在发生 B 操作的时候，操作 A 产生的影响能被 B 观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等

1. 程序次序原则：在单个线程中，程序按照代码的顺序执行，前面的代码操作必然发生于后面的代码操作之前
2. volatile 变量原则：对一个 volatile 变量的写操作，必然发生于后续对这个变量的读操作之前
3. 传递原则：如果操作 A 先于操作 B，操作 B 先于操作 C，那么操作 A 一定先于操作 C
4. 锁定原则：对一个锁的解锁操作必然发生于后续对这个锁的加锁操作之前
5. 线程启动原则：如果线程 1 调用线程 2 的 start()方法启动线程 2，则 start()操作必然发生于线程 2 的任意操作之前
6. 线程终结原则：如果线程 1 等待线程 2 完成操作，那么当线程 2 完成后，线程 1 能够访问到线程 2 修改后的共享变量的值
7. 线程中断原则：对线程 interrupt()方法的调用必然发生于被中断线程的代码检测到中断事件发生前
8. 对象终结原则：一个对象的初始化必然发生于它的 finalize()方法开始前

## as-if-serial 规则

as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变，编译器、runtime 和处理器都必须遵守 as-if-serial 语义。

为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。示例代码如下：

```java
int a=1;
int b=2;
int c=a+b;
```

a 和 c 之间存在数据依赖关系，同时 b 和 c 之间也存在数据依赖关系。因此在最终执行的指令序列中，c 不能被重排序到 A 和 B 的前面（c 排到 a 和 b 的前面，程序的结果将会被改变）。但 a 和 b 之间没有数据依赖关系，编译器和处理器可以重排序 a 和 b 之间的执行顺序。

**as-if-serial 和 happens-before 的区别**

1. as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。
2. as-if-serial 语义给编写单线程程序的程序员创造了一个幻觉：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻觉：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。
3. as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。