---
title: 函数式接口
tag: 工作技巧
category: Java
description: 函数式接口是指仅包含一个抽象方法的接口，通常用于 lambda 表达式和方法引用的目标类型。在 Java 8 中，java.util.function 包含了多种常用的函数式接口，如 Predicate、Function、Consumer 等，极大地简化了函数式编程的实现。
date: 2024-10-25 22:38:34
---

## 函数式接口

特点：有且仅有一个抽象方法的接口

检测是否为函数式接口：@FunctionalInterface，放在接口定义的上方，如果接口是函数式接口，编译通过，不是则编译失败

@FunctionalInterface是可选的，只要保证满足函数式接口定义的条件，也是函数式接口

```java
@FunctionalInterface
public interface MyInter {
    void show();
}
```

1. 如果方法的参数是一个函数式接口，可以使用Lambda表达式作为参数传递

```java
public static void main(String[] args) {
    startThread(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+"启动");
        }
    });
    startThread(()-> System.out.println(Thread.currentThread().getName()+"启动"));
}

private static void startThread(Runnable r){
    new Thread(r).start();
}
```

2. 如果方法的返回值是一个函数式接口，可以使用Lambda表达式作为结果返回

```java
public static void main(String[] args) {
    ArrayList<String>arrayList=new ArrayList<String>();
    arrayList.add("das");
    arrayList.add("fdfs");
    arrayList.add("vcxvv");
    Collections.sort(arrayList,getComparator());
    System.out.println(arrayList);
}

private static Comparator<String> getComparator(){
    /* Comparator<String>comparator=new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length()-o2.length();
            }
        };
        return comparator;*/
    /* return new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length()-o2.length();
            }
        };*/
    return (s1,s2)-> s1.length()-s2.length();
}
```

## Comparator（比较器）

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

```java
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);
Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");
comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0
```

## Supplier（供应）

```java
@FunctionalInterface
public interface Supplier<T> {
    // 获取结果
    T get();
}
```

```java
public static void main(String[] args) {
    String s = getString(() -> "da");
    System.out.println(s);
    Integer integer = getInteger(() -> 123);
    System.out.println(integer);
}

private static String getString(Supplier<String> supplier) {
    return supplier.get();
}

private static Integer getInteger(Supplier<Integer> supplier) {
    return supplier.get();
}
```

## Consumer（消费）

```java
@FunctionalInterface
public interface Consumer<T> {
    // 对给定的参数执行此操作
    void accept(T t);
    
    // 返回一个组合的Consumer，依次执行此操作，然后执行after操作
	default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

```java
public static void main(String[] args) {
    operatorString("da", s-> System.out.println(s));
    operatorString("da", System.out::println);
    System.out.println("-----------------------");
    operatorString("da", s-> System.out.println(s), s-> System.out.println(new StringBuilder(s).reverse().toString()));
}

private static void operatorString(String s, Consumer<String>consumer) {
    consumer.accept(s);
}

private static void operatorString(String s, Consumer<String>consumer, Consumer<String>consumer1) {
    // consumer.accept(s);
    // consumer1.accept(s);
    // 等于下面的操作
    consumer.andThen(consumer1).accept(s);
}
```

## Predicate（断言）

```java
@FunctionalInterface
public interface Predicate<T> {
    // 对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个布尔值
    boolean test(T t);
    
	// 返回一个组合判断，对应短路与
    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }

    // 返回一个逻辑的否定，对应逻辑非
    default Predicate<T> negate() {
        return (t) -> !test(t);
    }

    // 返回一个组合判断，对应短路或
    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }

    static <T> Predicate<T> isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -> targetRef.equals(object);
    }
}
```

```java
public static void main(String[] args) {
     boolean cxz = checkString("cxz", s -> s.length() > 8);
     System.out.println(cxz);
     boolean ccxz = checkString("ccxz", s -> s.length() > 3, s -> s.length() < 11);
     System.out.println(ccxz);
}

private static boolean checkString(String s, Predicate<String>predicate){
    //return predicate.test(s);
    return predicate.negate().test(s);
}

private static boolean checkString(String s, Predicate<String> predicate, Predicate<String> predicate1){
    /*boolean test = predicate.test(s);
        boolean test1 = predicate1.test(s);
        return test&&test1;*/
    //return predicate.and(predicate1).test(s);
    return predicate.or(predicate1).test(s);
}
```

## Function（功能）

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);

    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }

    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }

    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
```

```java
public static void main(String[] args) {
    convert("100", s-> Integer.parseInt(s));
    convert("100", Integer::parseInt);
    convert(100, i-> String.valueOf(i+100));
    convert("100", s-> Integer.parseInt(s), s-> String.valueOf(s+100));
}

private static void convert(String s, Function<String,Integer> function) {
    Integer apply = function.apply(s);
    System.out.println(apply);
}

private static void convert(int i, Function<Integer,String> function) {
    String apply = function.apply(i);
    System.out.println(apply);
}

private static void convert(String s, Function<String,Integer> function, Function<Integer,String> function1) {
    // Integer apply = function.apply(s);
    // String apply1 = function1.apply(apply);
    // System.out.println(apply1);
    // 等于下面的操作
    String apply = function.andThen(function1).apply(s);
    System.out.println(apply);
}
```