

## getSuperclass()

返回直接继承的父类（由于编译擦除，没有显示泛型参数）

1. 如果此 `Class` 表示 `Object` 类、一个接口、一个基本类型或 void，则返回 null。
2. 如果此对象表示一个数组类，则返回表示该 `Object` 类的 `Class` 对象。 

## getGenericSuperclass()

这个可以用来获取所继承的超类的类型。返回的 Type，表示 Class 对象对应的实体（类、接口、基元类型或 void）的直接超类的 Type。

```java
Type type1 = ArrayList.class.getGenericSuperclass();
System.out.println("ArrayList.class的超类的类型："+type1.getTypeName());
// 下标0表示第1个参数，若有多个参数可递增
System.out.println("ArrayList.class的超类的泛型参数类型："+((ParameterizedType)type1).getActualTypeArguments()[0]); 

// 打印结果如下：
// ArrayList.class的超类的类型：java.util.AbstractList<E>
// ArrayList.class的超类的泛型参数类型：E
```

这个是只能获取直接超类（第一级超类）的类型，如果还需要获取超类的超类的类型，可以加上 getSuperclass()。

```java
Type type1 = ArrayList.class.getSuperclass().getGenericSuperclass();
System.out.println("ArrayList.class的超类的超类的类型："+type2.getTypeName());
// 下标0表示第1个参数，若有多个参数可递增
System.out.println("ArrayList.class的超类的超类的泛型参数类型："+((ParameterizedType)type2).getActualTypeArguments()[0]); 

// 打印结果如下：
// ArrayList.class的超类的超类的类型：java.util.AbstractCollection<E>
// ArrayList.class的超类的超类的泛型参数类型：E
```

## getInterfaces()

返回直接实现的接口（由于编译擦除，没有显示泛型参数）

1. 如果此对象表示一个类，则返回值是一个数组，它包含了表示该类所实现的所有接口的对象。数组中接口对象顺序与此对象所表示的类的声明的 `implements` 子句中接口名顺序一致
2. 如果此对象表示一个接口，则该数组包含表示该接口扩展的所有接口的对象。数组中接口对象顺序与此对象所表示的接口的声明的 `extends` 子句中接口名顺序一致
3. 如果此对象表示一个不实现任何接口的类或接口，则此方法返回一个长度为 0 的数组
4. 如果此对象表示一个基本类型或 void，则此方法返回一个长度为 0 的数组

## getGenericInterfaces()

这个可以用来获取所实现的接口的类型。返回的 Type，表示 Class 对象对应的类或接口所实现的接口的类型数组（因为 JAVA 中类可实现/接口可继承 N 个接口）。

```java
// 下标0表示所实现接口中的第1个
Type type2 = ArrayList.class.getGenericInterfaces()[0];
System.out.println("ArrayList.class实现的第1个接口的类型："+type2.getTypeName());
System.out.println("返回值type2本身的实际类型："+type2.getClass());
// 实际类型为ParameterizedTypeImpl的，可以强转，继续获取泛型参数的类型；若为java.lang.Class，则表示不是泛型
System.out.println("ArrayList.class实现的第1个接口的泛型参数类型："+((ParameterizedType)type2).getActualTypeArguments()[0]);

// 打印结果如下：
// ArrayList.class实现的第1个接口的类型：java.util.List<E>
// 返回值type2本身的实际类型：class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl
// ArrayList.class实现的第1个接口的泛型参数类型：E
```

这个一样只能获取到直接实现的 N 个接口（第一级接口），如果需要获取所实现接口的所实现接口的类型，就需要将获取到的类型转为 Class 对象，再重复执行方法。如果是接口类型是泛型的，则不能用 getTypeName()，而是需要用 getRawType()。

```java
try {
     Class clazz = Class.forName(((ParameterizedType) type2).getRawType().getTypeName());
     Type type3 = clazz.getGenericInterfaces()[0];
     System.out.println("type3="+type3.getTypeName());
} catch (ClassNotFoundException e) {
     throw new RuntimeException(e);
}

// 打印结果如下：
// type3=java.util.SequencedCollection<E>
```

## 使用案例

JAVA 中获取类的超类（父类）或接口的 class 类型

```java
public interface DealHandler<K, T> {

    T getTValue(K k);

    default Class<T> getTClass() {
        // 获取实现类中的T的class类型
        // 从父类中获取泛型参数
        Type superclass = this.getClass().getGenericSuperclass();
        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            if (actualTypeArguments.length > 1) {
                System.out.println("从父类成功获取到类型");
                return (Class<T>) actualTypeArguments[1];
            }
        }
        
        // 如果从父类获取不到，则尝试从接口获取
        Type[] genericInterfaces = this.getClass().getGenericInterfaces();
        for (Type genericInterface : genericInterfaces) {
            if (genericInterface instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType) genericInterface;
                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
                if (actualTypeArguments.length > 1) {
                    System.out.println("从接口成功获取到类型");
                    return (Class<T>) actualTypeArguments[1];
                }
            }
        }
        throw new UnsupportedOperationException("无法获取泛型类型T的Class");
    }
}
```

```java
public class DealHandlerImpl implements DealHandler<Integer, Double> {

    @Override
    public Double getTValue(Integer integer) {
        return 0.0;
    }

    public static void main(String[] args) {
        DealHandler<Integer, Double> dealHandler = new DealHandlerImpl();
        Class<Double> tClass = dealHandler.getTClass();
        System.out.println(tClass);
    }
}
```

```java
public abstract class DealHandlerTemplate<K, T> implements DealHandler<K, T> {
}
```

```java
public class DealHandlerTemplateImpl extends DealHandlerTemplate<Integer, String> {

    @Override
    public String getTValue(Integer integer) {
        return "";
    }

    public static void main(String[] args) {
        DealHandlerTemplate<Integer, String> dealHandlerTemplate = new DealHandlerTemplateImpl();
        Class<String> tClass = dealHandlerTemplate.getTClass();
        System.out.println(tClass);
    }
}
```

